 cp ภ       ภ      ษ      ำ       ำ      เ       เ      ๓      ๓                                                                        0       3       3       0       ออออออออออออออออออออออออออออออออออออออออ 	 $-66??HH-QZZcclluuZZ~ขขซซดดออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ  p  cp ็ ็      ็           ็      ็ ็  2   ็  2      2 ็    2 ออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ 		 $--66??$ $	-6?ออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ  p  cp        2       ฮ     2       ฮ     2       ฮ       ออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ   $ -			$	-$-$-ออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ  p  we pick up the bits for modifying u.;GetScreen	ldx		<Screen 		lda		#95 		suba		<Y1p 		ldb		#BytesPerRow 		mul				leax		d,x 		ldb		<X1p 		addb		#$80 		tfr		b,a 		lsrb				lsrb				lsrb				abx				anda		#7 		ldu		#BitTable		leau		a,u 		rts		BitTable	fcb		$80			; for setting points on graphics screen		fcb		$40 		fcb		$20 		fcb		$10 		fcb		$8 		fcb		$4 		fcb		$2 LastBit		fcb		$1 		end		Start1 		bra		j@ m@		stx		<X2			; move x2,y2 to top or right boundary, recover x1,y1		sty		<Y2 		puls		x,y 		stx		<X1 		sty		<Y1 n@		lda		<X2p			; decide if slope > 1		suba		<X1p 			; x1p, etc hold correct one-byte signed values for the coordinates, which are now on the virtual screen		pshs		a 		ldb		<Y1p 		subb		<Y2p 		cmpb		,S+ 		blo		p@ ;; draw a line with negative slope <= -1;		pshs		b			; save number of points on line - 1		jsr		GetSlope		; slope = -dx/dy, an 8-bit fraction		jsr		GetScreen		; set x,u to point to byte and bit on graphics screen corresp. to x1,y1		puls		b 		clra				tfr		d,y 		leay		1,y			; y=#points on line		clrb		o@		lda		,x			; set the points on the graphics screen for the line		ora		,u			; get the byte and or in the bit		sta		,x 		leay		-1,y			; reduce point count		lbeq		LineExit 		leax		BytesPerRow,x 		; decrease y-coordinate by 1		addb		<Slope			; increase x-coordinate by slope (a fraction)		bcc		o@			; b=x mod 1		leau		1,u			; increase x-coordinate by 1		cmpu		#LastBit		; try to move right one bit		bls		o@ 		ldu		#BitTable		; else use next byte and left bit		leax		1,x 		bra		o@ ;; draw line with negative slope > -1;p@		pshs		a			; save # points on line - 1		exg		a,b 		jsr		GetSlope		; slope = -dy/dx		jsr		GetScreen		; x,u are byte and bit corresp. to x1,y1		puls		b 		clra				tfr		d,y 		leay		1,y			; y=#points on line		clrb		q@		lda		,x			; draw the line		ora		,u			; get the byte, or in  the bit		sta		,x 		leay		-1,y			; reduce the point count		beq		s@ 		leau		1,u			; move one bit to the right		cmpu		#LastBit		; if possible		bls		r@ 		leax		1,x			; else move to next byte and first bit		ldu		#BitTable r@		addb		<Slope 		bcc		q@			; no overflow to next integer when adding slope to y		leax		BytesPerRow,x 		; else subtract 1 from y-coordinate		bra		q@ s@		rts;; assume a<b contain unsigned integers, put a/b into slope;GetSlope	stb		<Temp		clrb				ldx		#8 a@		aslb				asla				bcs		b@ 		cmpa		<Temp		blo		c@ b@		suba		<Temp		incb		c@		leax		-1,x 		bne		a@ 		stb		<Slope		rts;; find byte x and bit (u) on graphics screen corresponding to x1,y1; x=<SCREEN+y1*32+x1div8 and u=#bits+x1mod8; we use <Screen+y1*(256/8)+x1div8 for x, and as we divide x1 by three successive 2's,n		; x,u are byte and bit corresp. to x1,y1		puls		b 		clra				tfr		d,y 		leay		1,y			; y=#points on line		clrb		q@		lda		,x			; draw the line		ora		,u			; get the byte, or in  the bit		sta		,x 		leay		-1,y			; reduce the point count		beq		LineExit2 		leau		1,u			; move one bit to right		cmpu		#LastBit		; if possible		bls		r@ 		leax		1,x			; else move to next byte and first bit		ldu		#BitTable r@		addb		<Slope 		bcc		q@			; no overflo to next integer when adding slope to y		leax		-BytesPerRow,x 		; else add 1 to y-coordinate		bra		q@ LineExit2	rtsNoLine2		puls		x,y,pc;; draw line with negative slope;LineNS		ldd		<X1 			; check for no visible line		cmpd		#Right 		bge		LineExit2		ldd		<Y1 		cmpd		#Bottom 		ble		LineExit2		ldd		<X2 		cmpd		#Left 		ble		LineExit2		ldd		<Y2 		cmpd		#Top 		bge		LineExit2		ldd		<X1 			; check if must clip left end of line		cmpd		#Left 		blt		a@ 		ldd		<Y1 		cmpd		#Top 		ble		h@ a@		ldx		<X2 			; clip left end of line		ldy		<Y2 		pshs		x,y b@		ldd		X1			; x=(x1+x2)/2		addd		<X2 		asra				rorb				tfr		d,x 		ldd		Y1			; y=(y1+y2)/2		addd		<Y2 		asra				rorb				tfr		d,y 		cmpx		#Left 		bgt		c@ 		cmpy		#Bottom 		ble		NoLine2			; no visible linec@		cmpx		#Right 		blt		d@ 		cmpy		#Top 		bge		NoLine2			; no visible lined@		cmpx		#Left 		blt		e@ 		cmpy		#Top 		ble		f@ e@		stx		<X1			; replace left point by midpoint and repeat		sty		<Y1 		bra		b@ f@		cmpx		#Left 		ble		g@ 		cmpy		#Top 		bge		g@ 		stx		<X2			; replace right point by midpoint		sty		<Y2 		bra		b@ g@		stx		<X1			; x1,y1 now on left or bottom boundary		sty		<Y1 		puls		x,y			; recover original right point		stx		<X2 		sty		<Y2 h@		ldd		<X2 			; check if must clip right end of line		cmpd		#Right 		bgt		i@ 		ldd		<Y2 		cmpd		#Bottom 		bge		n@ i@		ldx		<X1 			; clip right end of line		ldy		<Y1 		pshs		x,y j@		ldd		<X1			; x=(x1+x2)/2		addd		<X2 		asra				rorb				tfr		d,x 		ldd		<Y1			; y=(y1+y2)/2		addd		<Y2 		asra				rorb				tfr		d,y 		cmpx		#Right 		bgt		k@ 		cmpy		#Bottom 		bge		l@ k@		stx		<X2			; move right point to midpoint and repeat		sty		<Y2 		bra		j@ l@		cmpx		#Right 		bge		m@ 		cmpy		#Bottom 		ble		m@ 		stx		<X1			; move left point to midpoint and repeat		sty		<Y 		ble		NoLine			; no visible lined@		cmpx		#Left 		blt		e@ 		cmpy		#Bottom 		bge		f@ e@		stx		<X1			; replace left point by midpoint and repeat		sty		<Y1 		bra		b@ f@		cmpx		#Left 		ble		g@ 		cmpy		#Bottom 		ble		g@ 		stx		<X2			; replace right point by midpoint		sty		<Y2 		bra		b@ g@		stx		<X1			; x1,y1 now on left or bottom boundary		sty		<Y1 		puls		x,y			; recover original right point		stx		<X2 		sty		<Y2 h@		ldd		<X2 			; check if must clip right end of line		cmpd		#Right 		bgt		i@ 		ldd		<Y2 		cmpd		#Top 		ble		n@ i@		ldx		<X1 			; clip right end of line		ldy		<Y1 		pshs		x,y j@		ldd		<X1			; x=(x1+x2)/2		addd		<X2 		asra				rorb				tfr		d,x 		ldd		<Y1			; y=(y1+y2)/2		addd		<Y2 		asra				rorb				tfr		d,y 		cmpx		#Right 		bgt		k@		cmpy		#Top 		ble		l@k@		stx		<X2			; move right point to midpoint and repeat		sty		<Y2 		bra		j@ l@		cmpx		#Right 		bge		m@		cmpy		#Top 		bge		m@ 		stx		<X1			; move left point to midpoint and repeat		sty		<Y1 		bra		j@ m@		stx		<X2			; move x2,y2 to top or right boundary, recover x1,y1		sty		<Y2 		puls		x,y 		stx		<X1 		sty		<Y1 n@		lda		<X2p			; decide if slope > 1		suba		<X1p 			; x1p, etc hold correct one-byte signed values for the coordinates, which are now on the virtual screen		pshs		a 		ldb		<Y2p 		subb		<Y1p 		cmpb		,S+ 		blo		p@ ;; draw a line with positive slope >=1;		pshs		b			; save number of points on line - 1		jsr		GetSlope		; slope = dx/dy, an 8-bit fraction		jsr		GetScreen		; set x,u to point to byte and bit on graphics screen corresp. to x1,y1		puls		b 		clra				tfr		d,y 		leay		1,y			; y=#points on line		clrb		o@		lda		,x			; set the points on the graphics screen for the line		ora		,u			; get the byte and or in the bit		sta		,x 		leay		-1,y			; reduce point count		lbeq		LineExit 		leax		-BytesPerRow,x 		; increase y-coordinate by 1		addb		<Slope			; increase x-coordinate by slope (a fraction)		bcc		o@			; b=x mod 1		leau		1,u			; increase x-coordinate by 1		cmpu		#LastBit		; try to move right one bit		bls		o@ 		ldu		#BitTable		; else use next byte and left bit		leax		1,x 		bra		o@ ;; draw line with positive slope <1;p@		pshs		a			; save # of points on line - 1		exg		a,b 		jsr		GetSlope		; slope = dy/dx		jsr		GetScreength < 1 -- if one found, restore points to original values		ldu		#Lines a@		clra				ldb		,U+ 		cmpb		#$ff 		beq		exit@			; last line segment tested		addd		#Points 		tfr		d,x			; address of first point		clra				ldb		,U+ 		addd		#Points 		tfr		d,y			; address of second point		ldd		,x 		cmpd		,y			; test first coord		bne		a@			; integer parts not equal		ldd		3,x 		cmpd		3,y 		bne		a@			; integer parts of second coord not equal		ldd		6,x 		cmpd		6,y 		bne		a@			; integer parts of third coord not equal		jmp		Bigger 			; all components of line segment have equal integer parts, so undo smaller and rts from biggerexit@		rts					; all line segments checked and long enoughShrink		leau		-3,s 		ldd		,x 		std		,u 		lda		2,x 		sta		2,u 		asr		,u 		ror		1,u 		ror		2,u 		asr		,u 		ror		1,u 		ror		2,u 		asr		,u 		ror		1,u 		ror		2,u 		asr		,u 		ror		1,u 		ror		2,u 		asr		,u 		ror		1,u 		ror		2,u 		ldd		1,x 		subd		1,u 		std		1,x 		lda		,x 		sbca		,u 		sta		,x 		rts		Top		equ		$5f			; limits of virtual screenBottom		equ		-$60-8 Left		equ		-$80 Right		equ		$7f LineExit	rtsNoLine		puls		x,y,pc;; draw a line. x1,x2 to y1,y2 - coordinates are signed 16 bit integers, visible screen is -128 to 127, -95 to 95 on usual x,y graph;Line		ldd		<X2 			; make sure x1<x2 or reverse coordinates		cmpd		<X1 		bge		a@ 		ldx		<X1 		std		<X1 		stx		<X2 		ldx		<Y1 		ldy		<Y2 		stx		<Y2 		sty		<Y1 a@		ldd		<Y2                     ; check for sign of slope		cmpd		<Y1 		lblt		LineNS			; draw line with a negative slope;; draw line with a positive slope;		ldd		<X1                     ; check for no visible line		cmpd		#Right 		bge		LineExit 		ldd		<Y1 		cmpd		#Top 		bge		LineExit 		ldd		<X2 		cmpd		#Left 		ble		LineExit 		ldd		<Y2 		cmpd		#Bottom 		ble		LineExit 		ldd		<X1 			; check if must clip left end of line		cmpd		#Left 		blt		a@		ldd		<Y1 		cmpd		#Bottom 		bge		h@ a@		ldx		<X2                     ; clip left end of line		ldy		<Y2 		pshs		x,y b@		ldd		<X1			; x=(x1+x2)/2		addd		<X2 		asra				rorb				tfr		d,x 		ldd		<Y1			; y=(y1+y2)/2		addd		<Y2 		asra				rorb				tfr		d,y 		cmpx		#Left 		bgt		c@ 		cmpy		#Top 		bge		NoLine			; no visible linec@		cmpx		#Right 		blt		d@ 		cmpy		#Bottom		sta		2,u 		lda		1,u 		sbca		4,u 		sta		1,u 		lda		,u 		sbca		3,u 		sta		,u 		ldd		,u 		std		,x 		lda		2,u 		sta		2,x 		ldd		,y 		std		3,u 		lda		2,y 		sta		5,u 		asr		,u 		ror		1,u 		ror		2,u 		asr		,u 		ror		1,u 		ror		2,u 		asr		,u 		ror		1,u 		ror		2,u 		ldd		1,u 		addd		4,u 		std		1,u 		lda		,u 		adca		3,u 		sta		,u 		asr		3,u 		ror		4,u 		ror		5,u 		asr		3,u 		ror		4,u 		ror		5,u 		asr		3,u 		ror		4,u 		ror		5,u 		asr		3,u 		ror		4,u 		ror		5,u 		asr		3,u 		ror		4,u 		ror		5,u 		asr		3,u 		ror		4,u 		ror		5,u 		asr		3,u 		ror		4,u 		ror		5,u 		ldd		1,u 		addd		4,u 		std		1,u 		lda		,u 		adca		3,u 		sta		,u 		ldd		,u 		std		,y 		lda		2,u 		sta		2,y 		rts		;; make the object 1/32 bigger;Bigger		ldx		#Points a@		lda		,x			; check if point is defined		cmpa		#$80 		beq		b@ 		bsr		Expand			; increase all three coordinates		leax		3,x 		bsr		Expand 		leax		3,x 		bsr		Expand 		leax		-6,x 		leay		,x			; chec if any of 3 coords too big		bsr		TooBig 		bge		c@ 		leay		3,y 		bsr		TooBig 		bge		c@ 		leay		3,y 		bsr		TooBig 		bge		c@ b@		leax		9,x			; get next point		cmpx		#LastPoint 		ble		a@ 		rts		c@		lda		,x			; restore points if one made out of bounds		cmpa		#$80 		bne		d@ 		leax		-9,x 		bra		e@ d@		jsr		Shrink 		leax		3,x 		jsr		Shrink 		leax		3,x 		jsr		Shrink 		leax		-$f,x e@		cmpx		#Points 		bhs		c@ 		rts		Expand		leau		-3,s			; make one coordinate 1/32 bigger		ldd		,x 		std		,u 		lda		2,x 		sta		2,u 		asr		,u 		ror		1,u 		ror		2,u 		asr		,u 		ror		1,u 		ror		2,u 		asr		,u 		ror		1,u 		ror		2,u 		asr		,u 		ror		1,u 		ror		2,u 		asr		,u 		ror		1,u 		ror		2,u 		ldd		1,x 		addd		1,u 		std		1,x 		lda		,x 		adca		,u 		sta		,x 		rts		TooBig		lda		,y			; check if a coordinate too big--if first byte >= $80 or <= -$80		cmpa		#$10 		bge		a@		nega				cmpa		#$10 a@		rts					; bge will go if number loaded into a was >=$10 or <=-$10;; make the object 1/32 smaller;Smaller		ldx		#Points a@		lda		,x			; check if point is defined		cmpa		#$80 		beq		b@ 		bsr		Shrink 		leax		3,x 		bsr		Shrink 		leax		3,x 		bsr		Shrink 		leax		3,x 		bra		c@ b@		leax		9,x			; get next pointc@		cmpx		#LastPoint 		ble		a@; check for line segment le	ble		a@ 		rts		c@		pshs		x			; undo rotations as  one point too large		lda		,x 		cmpa		#$80 		beq		d@ 		leay		,x 		leax		6,x 		jsr		Rotate d@		puls		x 		leax		-9,x 		cmpx		#Points 		bhs		c@ 		rts		RotateZ		ldx		#Points 		; rotate positively about z axisa@		lda		,x 		cmpa		#$80			; check for undefined point		beq		b@ 		pshs		x 		leay		3,x			; address of y-coordinate of current point--x has x-coordinate		jsr		Rotate 		puls		x 		lda		,x 		cmpa		#$10 		bge		c@ 		cmpa		#-$10 		ble		c@			; point too big		lda		3,x 		cmpa		#$10 		bge		c@ 		cmpa		#-$10 		ble		c@ b@		leax		9,x			; get next point		cmpx		#LastPoint 		ble		a@ 		rts		c@		pshs		x			; undo rotations as  one point too large		lda		,x 		cmpa		#$80 		beq		d@ 		leay		,x 		leax		3,x 		jsr		Rotate d@		puls		x 		leax		-9,x 		cmpx		#Points 		bhs		c@ 		rts		RotateZm	ldx		#Points 		; rotate negatively about z axisa@		lda		,x 		cmpa		#$80			; check for undefined point		beq		b@ 		pshs		x 		leay		,x			; address of x-coordinate of current point		leax		3,x			; address of y-coordinate of current point		jsr		Rotate 		puls		x 		lda		,x 		cmpa		#$10 		bge		c@ 		cmpa		#-$10 		ble		c@			; point too big		lda		3,x 		cmpa		#$10 		bge		c@ 		cmpa		#-$10 		ble		c@ b@		leax		9,x			; get next point		cmpx		#LastPoint 		ble		a@ 		rts		c@		pshs		x			; undo rotations as  one point too large		lda		,x 		cmpa		#$80 		beq		d@ 		leay		3,x 		jsr		Rotate 		puls		x d@		leax		-9,x 		cmpx		#Points 		bhs		c@ 		rts		;; rotate around an axis as follows:  x = coord pointed at by x-reg, y=coord pointed at by y-reg; x,y=(127/128)x-(1/8)y,(1/8)x+127/128)y;Rotate		leau		-6,s 		ldd		,x 		std		,u 		std		3,u 		lda		2,x 		sta		2,u 		sta		5,u 		asr		3,u 		ror		4,u 		ror		5,u 		asr		3,u 		ror		4,u 		ror		5,u 		asr		3,u 		ror		4,u 		ror		5,u 		asr		3,u 		ror		4,u 		ror		5,u 		asr		3,u 		ror		4,u 		ror		5,u 		asr		3,u 		ror		4,u 		ror		5,u 		asr		3,u 		ror		4,u 		ror		5,u 		lda		2,u 		suba		5,u 		sta		2,u 		lda		1,u 		sbca		4,u 		sta		1,u 		lda		,u 		sbca		3,u 		sta		,u 		ldd		,y 		std		3,u 		lda		2,y 		sta		5,u 		asr		3,u 		ror		4,u 		ror		5,u 		asr		3,u 		ror		4,u 		ror		5,u 		asr		3,u 		ror		4,u 		ror		5,u 		lda		2,u 		suba		5,u e of current point		leay		3,x			; address of z-coordinate of current point		jsr		Rotate 		puls		x 		lda		3,x 		cmpa		#$10 		bge		c@ 		cmpa		#-$10 		ble		c@			; point too big		lda		6,x 		cmpa		#$10 		bge		c@ 		cmpa		#-$10 		ble		c@ b@		leax		9,x			; get next point		cmpx		#LastPoint 		ble		a@ 		rts		c@		pshs		x			; undo rotations as  one point too large		lda		,x 		cmpa		#$80 		beq		d@ 		leay		3,x 		leax		6,x 		jsr		Rotate d@		puls		x 		leax		-9,x 		cmpx		#Points 		bhs		c@ 		rts		RotateXm	ldx		#Points 		; rotate negatively about x axisa@		lda		,x 		cmpa		#$80			; check for undefined point		beq		b@ 		pshs		x 		leay		3,x			; address of y-coordinate of current point		leax		6,x			; address of z-coordinate of current point		jsr		Rotate 		puls		x 		lda		3,x 		cmpa		#$10 		bge		c@ 		cmpa		#-$10 		ble		c@			; point too big		lda		6,x 		cmpa		#$10 		bge		c@ 		cmpa		#-$10 		ble		c@ b@		leax		9,x			; get next point		cmpx		#LastPoint 		ble		a@ 		rts		c@		pshs		x			; undo rotations as  one point too large		lda		,x 		cmpa		#$80 		beq		d@ 		leax		3,x 		leay		3,x 		jsr		Rotate d@		puls		x 		leax		-9,x 		cmpx		#Points 		bhs		c@ 		rts		RotateY		ldx		#Points 		; rotate positively about y axisa@		lda		,x 		cmpa		#$80			; check for undefined point		beq		b@ 		pshs		x 		leay		,x			; address of x-coordinate of current point		leax		6,x			; address of z-coordinate of current point		jsr		Rotate 		puls		x 		lda		,x 		cmpa		#$10 		bge		c@ 		cmpa		#-$10 		ble		c@			; point too big		lda		6,x 		cmpa		#$10 		bge		c@ 		cmpa		#-$10 		ble		c@ b@		leax		9,x			; get next point		cmpx		#LastPoint 		ble		a@ 		rts		c@		pshs		x			; undo rotations as  one point too large		lda		,x 		cmpa		#$80 		beq		d@ 		leay		6,x 		jsr		Rotate d@		puls		x 		leax		-9,x 		cmpx		#Points 		bhs		c@ 		rts		RotateYm	ldx		#Points 		; rotate negatively about y axisa@		lda		,x 		cmpa		#$80			; check for undefined point		beq		b@ 		pshs		x 		leay		6,x			; address of z-coordinate of current point--x contains x-coord		jsr		Rotate 		puls		x 		lda		,x 		cmpa		#$10 		bge		c@ 		cmpa		#-$10 		ble		c@			; point too big		lda		6,x 		cmpa		#$10 		bge		c@ 		cmpa		#-$10 		ble		c@ b@		leax		9,x			; get next point		cmpx		#LastPoint 			<Screen 		cmpx		#Page1 		beq		a@ 		ldx		#Page1 		ldd		#($70000+Page2)/8 		bra		b@ a@		ldx		#Page2 		ldd		#($70000+Page1)/8 b@		std		$ff9d 		stx		<Screen			; first byte of unseen video screenskip@		rts		PanLeft		ldx		#Points a@		lda		,x 		cmpa		#$80 		beq		b@ 		ldd		,x			; get x coordinate and subtract 2		subd		#2 		std		,x 		cmpa		#-$80 		ble		c@			; point out of boundsb@		leax		9,x 		cmpx		#LastPoint 		bls		a@ 		rts		c@		lda		,x			; since one point out of bounds, restore all points to original values		cmpa		#$80 		beq		d@		lda		1,x 		adda		#2 		sta		1,x 		lda		,x 		adca		#0 		sta		,x d@		leax		-9,x 		cmpx		#Points 		bhs		c@		rts		PanRight	ldx		#Points a@		lda		,x 		cmpa		#$80 		beq		b@			; if point undefined		ldd		,x			; add 2 to x coordinate		addd		#2 		std		,x 		cmpa		#$10 		bge		c@			; point out of boundsb@		leax		9,x 		cmpx		#LastPoint 		bls		a@ 		rts		c@		lda		,x			; since one point out of bounds, restore all points to  original values		cmpa		#$80 		beq		d@ 		lda		1,x 		suba		#2 		sta		1,x 		lda		,x 		sbca		#0 		sta		,x d@		leax		-9,x 		cmpx		#Points 		bhs		c@ 		rts		PanDown		ldx		#Points a@		lda		,x 		cmpa		#$80 		beq		b@			; if point undefined		ldd		3,x			; subtract 2 from y coordinate		subd		#2 		std		3,x 		cmpa		#-$10 		ble		c@			; if point out of boundsb@		leax		9,x 		cmpx		#LastPoint 		bls		a@ 		rts		c@		lda		,x			; since one point out of bounds, restore all points  to original values		cmpa		#$80 		beq		d@ 		lda		4,x 		adda		#2 		sta		4,x 		lda		3,x 		adca		#0 		sta		3,x d@		leax		-9,x 		cmpx		#Points 		bhs		c@ 		rts		PanUp		ldx		#Points a@		lda		,x 		cmpa		#$80 		beq		b@			; if point undefined		ldd		3,x			; add 2 to y coordinate		addd		#2 		std		3,x 		cmpa		#$10 		bge		c@			; point out of boundsb@		leax		9,x 		cmpx		#LastPoint 		bls		a@ 		rts		c@		lda		,x			; since one point out of bounds, restore all points  to original values		cmpa		#$80 		beq		d@ 		lda		4,x 		suba		#2 		sta		4,x 		lda		3,x 		sbca		#0 		sta		3,x d@		leax		-9,x 		cmpx		#Points 		bhs		c@ 		rts		RotateX		ldx		#Points 		; rotate positively about x axisa@		lda		,x 		cmpa		#$80			; check for undefined point		beq		b@ 		pshs		x 		leax		3,x			; address of y-coordinat;; Program <<DISPLAY>>; Pan, scale, and rotate contents of Points then display the contents of Lines;Page1		equ		$3e00			; graphics page 1Page2		equ		$5700			; graphics page 2ScreenWidth	equ		256 ScreenHeight    equ		200 BytesPerRow	equ		ScreenWidth/8 ScreenBytes	equ		ScreenHeight*BytesPerRow 		org		$7f00 		setdp		*/$100 DirectPage	equ		* Is6309		rmb		1 X1		rmb		1			; 2-byte coordinates for two pointsX1p		rmb		1 Y1		rmb		1 Y1p		rmb		1 X2		rmb		1 X2p		rmb		1 Y2		rmb		1 Y2p		rmb		1 Slope		rmb		1 Temp		rmb		1Screen		fdb		Page1			; contains the address of the first byte of the presently unseen graphics screen--pre-initializedDirty		rmb		1 Erase		rmb		1 		org		$7000 Points		rmb		9*26			; store three coords of three bytes each labeled a..z for the userLastPoint	equ		*-9                     ; unused points have $80 in the first byte of each coordinateLines		rmb		121			; up to 30 pairs of points, last pair followed by -1, point l represented by 9*(asc(l)-asc(a)); introductory housekeeping to disable basic interrupts and create new stack then restore environment for return to basicStart		pshs		cc 		orcc		#$50			; disable regular interrupt		clr		$ff40			; turn off drive motor		sta		$ffd7			; high speed		lda		#DirectPage/$100 		tfr		a,dp 		ldb		#$ff 		opt		6309 		clrd			 	        ; executes as a $10 (ignored) $4f (clra) on a 6809a@		stb		<Is6309 		bne		b@ 		ldmd		#1			; enable 6309 native mode		opt		6809 b@		leau		,s 		lds		#DirectPage		; use high memory for hardware stack		pshs		u 		lda		#68 		sta		$ff90 		lda		#%10000000 	        ; graphics mode		sta		$ff98 		lda		#%00101000 	        ; 256x200x2		sta		$ff99 		clra					; black		sta		$ff9a			; border		sta		$ffb0			; palette 0		lda		#63			; white		sta		$ffb1			; palette 1		bsr		Main 		puls		u 		leas		,u			; restore hardware stack		sta		$ffd6 		tst		<Is6309 		bne		a@ 		opt		6309 		ldmd		#0 		opt		6809 a@		clra				tfr		a,dp 		jsr		[$e002] 		; restore text mode		puls		cc,pc 			; exit to BASIC;; main display loop. looks for a key commanding rotation, panning, or scaling.;Main		lda		#1 		sta		<Dirty 		clr		<Erase a@		tst		<Dirty 		beq		b@ 		clr		<Dirty 		jsr		Display			; display the pictureb@		ldx		#CommandTable c@		lda		,x 		st                                                                                                                                                                                                                                                                ยยยย" $%ม'ม)*+,-./0ล23ม5ม789:;<=>ฦ@AยCม                                                                                                                                                                                            DISPLAY BAS  #                 DISPLAY BIN &                 DISPLAY ASM( ่                DISPLAY2BAS  1                 DISPLAY2BIN 4                 DISPLAY2ASM6                 DISPLAY3BAS  ? ก                DISPLAY3BIN B .                DISPLAY3ASM! ฃ                DIAMOND 3D   m                CUBE    3D   m                WORD    3D   m                a		$ff02 		lda		$ff00 		coma				pshs		a 		lda		1,x 		ora		#%01000000 	        ; preserve shift		anda		,s+ 		cmpa		1,x 		beq		e@ d@		leax		4,x 		tst		,x 		bne		c@ 		bra		a@ e@		pshs		x 		jsr		[2,X] 		puls		x 		inc		<Dirty 		bra		d@ CommandTable    fdb	%0111111000001000,RotateX       ; x		fdb	%0111111001001000,RotateXm 	; shift x		fdb	%0111110100001000,RotateY       ; y		fdb	%0111110101001000,RotateYm 	; shift y		fdb	%0111101100001000,RotateZ       ; z		fdb	%0111101101001000,RotateZm 	; shift z		fdb	%1111011100001000,PanUp	        ; up arrow		fdb	%1110111100001000,PanDown       ; down arrow		fdb	%1101111100001000,PanLeft       ; left arrow		fdb	%1011111100001000,PanRight      ; right arrow		fdb	%1111101100000001,Bigger	; b		fdb	%1111011100000100,Smaller	; s		fdb	%1111111001000000,Toggle 	; spacebar		fdb	%1111111000000001,Exit 	        ; @		fcb		0		        ; end of tableToggle		ldx		#5000			; debouncea@		leax		-1,x 		bne		a@ b@		lda		#%11111110 		sta		$ff02 		lda		$ff00 		coma				anda		#%01000000 		bne		b@ 		com		<Erase 		bne		a@ 		jmp		ClearScreen a@		ldx		<Screen 		cmpx		#Page1 		beq		b@ 		ldx		#Page1 		ldd		#($70000+Page1)/8 		bra		c@ b@		ldx		#Page2 		ldd		#($70000+Page2)/8 c@		stx		<Screen 		std		$ff9d 		rts		Exit		leas		4,s 		rts		ClearScreen     tst		<Erase 		bne		exit@ 		tst		<Is6309 		bne		a@ 		opt		6309 		ldx		<Screen 		ldy		#zero@ 		ldw		#ScreenBytes 		tfm		y,X+ 		opt		6809 		bra		exit@ zero@		fcb		0 a@		ldd		#0			; blank screen		ldx		<Screen 		leay		ScreenBytes,x 		sty		c@+1 		ldd		#0 b@		std		,X++ 		std		,X++ 		std		,X++ 		std		,X++ 		std		,X++ 		std		,X++ 		std		,X++ 		std		,X++ c@		cmpx		#0 		bne		b@ exit@		rts		;; plot the current lines on the unseen graphics screen then display the screen;Display         bsr		ClearScreen 				ldu		#Lines 			; plot each linea@		ldb		,U+ 		cmpb		#$ff 		beq		PageFlip 		; last point?		clra				addd		#Points 		tfr		d,y			; address of first point		ldx		,y 		stx		<X1 		leay		3,y 		ldx		,y 		stx		<Y1 		ldb		,U+ 		clra				addd		#Points 		tfr		d,y			; address of second point		ldx		,y 		stx		<X2 		leay		3,y 		ldx		,y 		stx		<Y2 		pshs		u 		jsr		Line 		puls		u 		bra		a@PageFlip	tst		<Erase 		bne		skip@ 		ldxู& d PROGRAM DISPLAY &; n COPYRIGHT DAVID MEREDITH 1983 &ป x BASIC PROGRAM PERMITS INPUT OF A 3-D PICTURE AS POINTS AND LINE SEGMENTS. MACHINE LANGUAGE COMPONENT DISPLAYS THE PICTURE &๋  AND ALLOWS PANNING, SCALING, AND ROTATING &  300,&H3FFF 'H :@73,"D I S P L A Y":@135,"BY DAVID MEREDITH":@201,"COPYRIGHT 1983" 'u @416,"READING MACHINE LANGUAGE PART..." ' ำM"DISPLAY" 'ํ POณ&H7000:LIณPOซ9ญ26:MAณLIซ121: ADDRESSES OF POINTS BUFFER, LINES BUFFER, AND MAIN DISPLAY ROUTINE '๚ ฅ CH(25) ( ชฆ 1000: NEW PICTURE (Y ฏCS$ณ"HELPNEWDISPLAY":LD$ณ"LOAD":SV$ณ"SAVE":AAณ("A"):QU$ณ(34) ( ด:"ENTER help ANYTIME FOR GUIDANCE" (ฎ พป A$: GET NEW POINT, LINE, OR COMMAND )  ศIณ(A$," "): Iดฒ0 ง A$ณ(A$,Iฌ1)ซ(A$,(A$)ฌI):ฅ 200: ELIMINATE BLANKS )y า (A$) ฒ2 ง Iณ(CS$,A$): Iณ0 ง 215 :  Iณ1 ง ฆ 1600:ฅ 190 :  Iณ5 ง ฆ 1000:ฅ 190 :  Iณ8 ง ฆ 1800:ฅ 190 )ภ ื (A$,LD$)ณ1 ง ฆ 1200:ฅ 190 :  (A$,SV$)ณ1 ง ฆ 1400:ฅ 190 )๕  (A$,"=")ณ2 ง ฆ 2000:ฅ 190: DEFINE A POINT *0 ๆ (A$,"??")ณ1 ง ฆ 2200:ฅ 190: PRINT LINE SEGMENTS *c ๐ (A$,"?")ณ1 ง ฆ 2400:ฅ 190: PRINT POINTS * ๚	AT THIS POINT A$ EITHER DEFINES LINES OR IS INCORRECT *็Lณ(A$): Lด2 ง ฆ 2600:ฅ 190: IF LEN(A$) <2 THEN LINE INCORRECT +f Lด2 ง 190 : A1ณ((A$,1))ฌAA:A2ณ((A$,2,1))ฌAA: A1ด0 ฑ A1ฒ25 ฑ A2ด0 ฑ A2ฒ25 ง ฆ 2600:ฅ 190 : LณLฌ2:A$ณ(A$,L) + A1ณA2 ง:"ENDPOINTS MUST BE DISTINCT"::ฅ190 +ฺ (A$,"#")ณ1 ง LณLฌ1:A$ณ(A$,L):ฅ 400: DELETE A POINT +๓IณLI:A1ณ9ญA1:A2ณ9ญA2 ,ล"Pณ(I):Qณ(Iซ1): P ดฒ 255 ง  (PณA1 ฐ QณA2) ฑ (PณA2 ฐ QณA1)ง :"LINE ";(AAซA1ฎ9);(AAซA2ฎ9);" ALREADY DEFINED"::ฅ 190 : IณIซ2:ฅ 290: FIND NEXT OPEN SPACE IN LINES BUFFERCHECKING FOR DUPLICATION ,๚, IณMAฌ1 ง :"NO ROOM FOR ANOTHER LINE"::ฅ190 -@6 (POซA1)ณ128 ง :"POINT ";(A1ฎ9ซAA);" NOT DEFINED"::ฅ 270 -@ (POซA2)ณ128 ง :"POINT ";(A2ฎ9ซAA);" NOT DEFINED"::ฅ 270 -๕J I,A1: Iซ1,A2: Iซ2,255: Lฒ0 ง 270 : 190: PUT LINE SEGMENT IN LINE BUFFER AND GET NEXT SEGMENT IF ANY .	DELETE A LINE SEGMENT A1,A2 .0IณLI:A1ณ9ญA1:A2ณ9ญA2 .ค (I)ณ255 ง :"LINE SEGMENT ";(A1ฎ9ซAA);(A2ฎ9ซAA);" NOT DEFINED"::ฅ 270 .อฎPณ(I):Qณ(Iซ1): (PดฒA1 ฑ QดฒA2) ฐ (PดฒA2 ฑ QดฒA1)ง IณIซ2:ฅ 420 /1ธPณ(Iซ2): I,P: Pณ255 ง 270 : IณIซ1:ฅ 440: DELETE THE POINT BY MOVING DATA DOWN THE BUFFER /L่ MAKE A BLANK PICTURE /๒ IณPO ฅ POซ9ญ25 ฉ 9: I,128:: MARK ALL POINTS AS UNDEFINED /ฏ LI,255: CLEAR LINE BUFFER /ต /ิฐ LOAD A PICTURE FROM DISK 02บIณ(A$,QU$):Iดฒ0งJณ(Iซ1,A$,QU$):Jดฒ0งNA$ณ(A$,I,JฌIซ1):NA$ณ(A$,(A$)ฌI):NA$ณ"" 0Oฤ(NA$)ฒ8งNA$ณ(NA$,8) 0`ฮำM NA$ซ".3D" 0ุฅ 1800: DISPLAY PICTURE AFTER LOADING 0ฏx SAVE CURRENT PICTURE ON DISK 1Iณ(A$,QU$):Iดฒ0งJณ(Iซ1,A$,QU$):Jดฒ0งNA$ณ(A$,I,JฌIซ1):NA$ณ(A$,(A$)ฌI):NA$ณ"" 1*(NA$)ฒ8งNA$ณ(NA$,8) 1HุM NA$ซ".3D",PO,MAฌ1,PO: 1[@ HELP ROUTINE 1~J:"DISPLAY PICTURE:  display" 1ณO"...PRESS x,y,z,s,b AND @ TO EXIT": &H400ซ55,0 1ฮT"ERASE PICTURE:  new" 1^"SAVE PIX ON DISK:  save";QU$;"NAME";QU$ 2,h"READ PIX FROM DISK:  load";QU$;"NAME";QU$ 2Mr"ENTER POINT P:  P = X,Y,Z" 2o|"ENTER LINE SEGMENT AB:  AB" 2"DELETE LINE SEGMENT CD:  CD#" 2ต"PRINT POINTS A TO H:  ?A-H" 2ี"PRINT LINE SEGMENTS:  ??" 2ค: 2๗ DISPLAY THE PICTURE 3* FIRST DECLARE ALL UNUSED POINTS AS UNDEFINED 3@Iณ0ฅ25:CH(I)ณ0: 3I&IณLI 30Pณ(I):Pดฒ255งCH(Pฎ9)ณ1:IณIซ1:ฅ1840: MARK ALL POINT NAMES USED 3ี:Iณ0ฅ25:CH(I)ณ0งPOซ9ญI,128:: MARK UNUSED POINTS AS UNDEFINED 3๓D 282,0:ข MA:282,255:: 4ะ INPUT A POINT 46ฺAณ((A$,1))ฌAA: Aด0 ฑ Aฒ25 ง ฆ 2600: 4DไADณPOซ9ญA 4[๎A$ณ(A$,(A$)ฌ2) 4s๘ A$ณ"" ง ฆ 2600: 4่VAณ(A$): (VA) ฒ 80 ง :"COORDINATES MUST BE BETWEEN -80 AND 80":: : Bณ(A$)ฌ((VA)): VA ด0 ง BณBฌ1 5; Bด3 ง ฆ 2600:ฅ 190 : A$ณ(A$,B): VAฒณ0 ง V1ณ0:V2ณVA : V1ณ255:V2ณ256ซVA 5b AD,V1: ADซ1,V2: ADซ2,0:ADณADซ3 5z A$ณ"" ง ฆ 2600: 5๏ VAณ(A$): (VA) ฒ 80 ง :"COORDINATES MUST BE BETWEEN -80 AND 80":: : Bณ(A$)ฌ((VA)): VA ด0 ง BณBฌ1 6A% Bด1 ง ฆ 2600:ฅ190 : A$ณ(A$,B): VAฒณ0 ง V1ณ0:V2ณVA : V1ณ255:V2ณ256ซVA 6h* AD,V1: ADซ1,V2: ADซ2,0:ADณADซ3 6ณ\VAณ(A$):(VA)ฒ80 ง :"COORDINATES MUST BE BETWEEN -80 AND 80":: 6aVAฒณ0งV1ณ0:V2ณVA :V1ณ255:V2ณ256ซVA 6๛f AD,V1:ADซ1,V2:ADซ2,0: 7 PRINT LINES 7ขIณLI 70ฌPณ(I): Pณ255 ง : 7cถ(Pฎ9ซAA);((Iซ1)ฎ9ซAA);" ";:IณIซ2:ฅ2220 7v	` PRINT POINTS 7ฤ	jA1ณ0:A2ณ25:Iณ(A$,"-"):Iณ3งA1ณ((A$,2,1))ฌAA:A1ด0ฑA1ฒ25งA1ณ0:ฅ2030 8 	tIด(A$)ฐIดณ3งA2ณ((A$,Iซ1,1))ฌAA:A2ด0ฑA2ฒ25งA2ณ25 8)	~IณA1 ฅ A2:ADณPOซ9ญI:(AD)ณ128ง: 8G	(IซAA);" = ";:Jณ0ฅ6ฉ3 8	VAณ(ADซJ)ญ256ซ(ADซJซ1)ซ(ADซJซ2)ฎ256:VAฒ32767งVAณVAฌ65536 8ช	V$ณ(VA):V$;:Jดฒ6ง","; 8ถ	ก::: 8ุ
(:"UNRECOGNIZED COMMAND"::    ๒qc@3ไฮ 4@ฝqz5@2ฤ๏9ทภทรทลถ"๐ท"ฝr$ญ '๚ฝw4&rฒ h	&r่ _^&sT V
&s Mx&s DX&sำ ;y&t 2Y&tc )z&tช  Z&t๑ b&v s&vฎ @&94ญ๘ฝr$ญ ฝw4แไ'๏2cn@ Oฦ  พr"ฏJ&๚Z&๗ฮp๊ๆภม'/Oรp ฎคฟwU1#ฎคฟwWๆภOรp ฎคฟwY1#ฎคฟw[4@ฝw^5@ หพr"@ 'ทิทฦทศทหทอทฮทัทา@ ฟr"9ทฦทศทสทฬทฮทัทาX ฟr"9p ฆ'์ ํ/0	pแ#่9ฆ'ฆงฆ ง0p $็9p ฆ'์ร ํ,0	pแ#่9ฆ'ฆงฆ ง0p $็9p ฆ'์ ํ๐/0	pแ#่9ฆ'ฆงฆ ง0p $็9p ฆ'์ร ํ,0	pแ#่9ฆ'ฆงฆ ง0p $็9p ฆ'401ฝu85ฆ,๐/ฆ,๐/0	pแ/ิ94ฆ'10ฝu850p $่9p ฆ'410ฝu85ฆ,๐/ฆ,๐/0	pแ/ิ94ฆ'01ฝu850p $่9p ฆ'410ฝu85ฆ,๐/ฆ,๐/0	pแ/ิ94ฆ'1ฝu850p $๊9p ฆ'41ฝu85ฆ,๐/ฆ,๐/0	pแ/ึ94ฆ'10ฝu850p $่9p ฆ'41ฝu85ฆ,๐/ฆ,๐/0	pแ/ึ94ฆ'10ฝu850p $่9p ฆ'410ฝu85ฆ,๐/ฆ,๐/0	pแ/ิ94ฆ'1ฝu850p $๊93z์ํฤํCฆงBงEgCfDfEgCfDfEgCfDfEgCfDfEgCfDfEgCfDfEgCfDfEฆBEงBฆAขDงAฆฤขCงฤ์คํCฆ"งEgCfDfEgCfDfEgCfDfEฆBEงBฆAขDงAฆฤขCงฤ์ฤํฆBง์คํCฆ"งEgฤfAfBgฤfAfBgฤfAfB์AใDํAฆฤฉCงฤgCfDfEgCfDfEgCfDfEgCfDfEgCfDfEgCfDfEgCfDfE์AใDํAฆฤฉCงฤ์ฤํคฆBง"9p ฆ'$ฝvo0ฝvo0ฝvo01ฝvค,1#ฝvค,1#ฝvค,0	pแ/ฯ9ฆ&0 ฝv0ฝv0ฝv0p $โ93}์ํฤฆงBgฤfAfBgฤfAfBgฤfAfBgฤfAfBgฤfAfB์ใAํฆฉฤง9ฆค,@9p ฆ'ฝv0ฝv0ฝv0 0	pแ/โฮp๊Oๆภม'%รp Oๆภรp ์ฃค&ๅ์ฃ#&์ฃ&&ื93}์ํฤฆงBgฤfAfBgฤfAfBgฤfAfBgฤfAfBgฤfAfB์ฃAํฆขฤง9๖R๛S๛T๛U๛V๛W๛X๛Y9@  w^wYณwU,พwUwUฟwYพwWพw[ฟw[ฟwWw[ณwW-wU ,wW _,wY/w[/๒wU-	wW,oพwYพw[40wU๓wYGVwW๓w[GV. _,ด -/ง-,	ฟwUฟwW พ//	ฟwYฟw[ ชฟwUฟwW50ฟwYฟw[wY .	w[ _/UพwUพwW40wU๓wYGVwW๓w[GV . _/	ฟwYฟw[ ุ , _,	ฟwUฟwW ฤฟwYฟw[50ฟwUฟwWถwZฐwV4๖w\๐wXแเ%34ฝzจฝzร5O1!_ฆชฤง1?'0เ๛w]$์3AwT#ไฮwM0 4ฝzจฝzร5O1!_ฆชฤง1?'ง3AwT#0ฮwM๛w]$โ0เ wU ,wW/zwY/ow[ _,dwU-	wW _/oพwYพw[40wU๓wYGVwW๓w[GV./& - _,- _/	ฟwUฟwW พ/ _,	ฟwYฟw[ ชฟwUฟwW50ฟwYฟw[wY .	w[,UพwUพwW40wU๓wYGVwW๓w[GV .,	ฟwYฟw[ ุ ,/	ฟwUฟwW ฤฟwYฟw[50ฟwUฟwWถwZฐwV4๖wX๐w\แเ%34ฝzจฝzร5O1!_ฆชฤง1?' N0 ๛w]$์3AwT#ไฮwM0 4ฝzจฝzร5O1!_ฆชฤง1?' 3AwT#0ฮwM๛w]$โ0  5094_ XH%กไ%ไ\0&๑2a๗w]9พr"_ฐwX๖wVหฮwMFV$3AGV$3BGV$3D09    ** PROGRAM <<DISPLAY>>* PAN, SCALE, AND ROTATE CONTENTS OF *POINTS* THEN DISPLAY THE CONTENTS OF *LINES**PAGE1	equ	$4000	; graphics page 1PAGE2	equ	$5800	; graphics page 2	org	$7000** BASIC DATA STRUCTURES--THE POINTS AND LINES TO BE DRAWN. POINTS MAINTAINS THE COORDINATES OF THE POINTS*POINTS	rmb	9*26	STORE THREE COORDS OF THREE BYTES EACH LABELED A..Z FOR THE USER* UNUSED POINTS HAVE $80 IN THE FIRST BYTE OF EACH COORDINATELINES	rmb	121	UP TO 30 PAIRS OF POINTS, LAST PAIR FOLLOWED BY -1, POINT L REPRESENTED BY 9*(ASC(L)-ASC(A))* INTRODUCTORY HOUSEKEEPING TO DISABLE BASIC INTERRUPTS AND CREATE NEW STACK THEN RESTORE ENVIRONMENT FOR RETURN TO BASIC*	orcc	#$10	DISABLE REGULAR INTERRUPT	clr	$ff40	TURN OFF DRIVE MOTOR	leau	,S	lds	#$8000	USE HIGH MEMORY FOR HARDWARE STACK	pshs	U	jsr	MAIN	puls	U	leas	,U	RESTORE HARDWARE STACK	andcc	#$EF	ENABLE REGULAR INTERRUPT	rts** MAIN DISPLAY LOOP--LOOKS FOR A KEY COMMANDING ROTATION, PANNING, OR SCALING AND ORDERS SSAME. INCLUDES AUTO REPEAT*MAIN	sta	$FFC0	SET VDG = 110	sta	$FFC3	sta	$FFC5	lda	$FF22	SET HI BITS CONTROL REGISTER = $F0	anda	#7	ora	#$F0	sta	$FF22	jsr	DISPLA	DISPLAY THE PICTUREKEY	jsr	[$A000]	beq	KEY	jsr	KEYVAL	cmpa	#$8	LEFT ARROW	bne	MAIN1	ldx	#PANL	bra	REPEATMAIN1	cmpa	#$9	RIGHT ARROW	bne	MAIN2	ldx	#PANR	bra	REPEATMAIN2	cmpa	#$5E	UP ARROW	bne	MAIN3	ldx	#PANU	bra	REPEATMAIN3	cmpa	#$0A	DOWN ARROW	bne	MAIN4	ldx	#PAND	bra	REPEATMAIN4	cmpa	#$78	UNSHIFTED X	bne	MAIN5	ldx	#ROTX	bra	REPEATMAIN5	cmpa	#$58	SHIFTED X	bne	MAIN6	ldx	#ROTMX	bra	REPEATMAIN6	cmpa	#$79	UNSHIFTED Y	bne	MAIN7	ldx	#ROTY	bra	REPEATMAIN7	cmpa	#$59	SHIFTED Y	bne	MAIN8	ldx	#ROTMY	bra	REPEATMAIN8	cmpa	#$7A	UNSHIFTED Z	bne	MAIN9	ldx	#ROTZ	bra	REPEATMAIN9	cmpa	#$5A	SHIFTED Z	bne	MAIN10	ldx	#ROTMZ	bra	REPEATMAIN10	cmpa	#$62	UNSHIFTED B	bne	MAIN11	ldx	#BIGGER	bra	REPEATMAIN11	cmpa	#$73	UNSHIFTED S	bne	MAIN12	ldx	#SMALLR	bra	REPEATMAIN12	cmpa	#$40	@	bne	KEY	NO COMMAND RECOGNIZED	rtsREPEAT	pshs	X,B	SAVE ADDRESS OF SUB CALLED BY LAST KEY AND SUM OF KEY BUFFERSREP1	jsr	[1,S]	1,S POINTS TO ADDRESS OF SUBROUTINE CALLED BY LAST KEY PRESSED	jsr	DISPLA	DISPLAY UPDATED POINTS	jsr	[$A000]	jsr	KEYVAL	cmpb	,S	beq	REP1	KEY STILL DEPRESSED	leas	3,S	RESTORE STACK	lbra	KEY	LOOK FOR ANOTHER COMMAND** CREATE A PICTURE USING CURRENT POINTS AND LINES ON THE UNSEEN GRAPHICS SCREEN THEN DISPLAY THAT SCREEN*TL	fdb	PAGE1	CONTAINS THE ADDRESS OF THE FIRST BYTE OF THE PRESENTLY UNSEEN GRAPHICS SCREEN--INITIALIZED SO** PLOT THE CURRENT LINES ON THE UNSEEN GRAPHICS SCREEN THEN DISPLAY THE SCREEN*DISPLA	clra	BLANK SCREEN	ldb	#$C	ldy	#0	ldx	TLDISP1	sty	,X++	deca	bne	DISP1	decb		bne	DISP1** PLOT EACH LINE*	ldu	#LINESDISP3	ldb	,U+	cmpb	#$FF	beq	DISP2	LAST POINT?	clraP1300	addd	#POINTS	tfr	D,Y	ADDRESS OF FIRST POINT	ldx	,Y	stx	X1	leay	3,Y	ldx	,Y	stx	Y1	ldb	,U+	clra	addd	#POINTS	tfr	D,Y	ADDRESS OF SECOND POINT	ldx	,Y	stx	X2	leay	3,Y	ldx	,Y	stx	Y2	pshs	U	jsr	LINE	puls	U	bra	DISP3** SWITCH SCREENS TO SHOW NEW PICTURE*DISP2	ldx	TL	cmpx	#PAGE1	beq	DISP4	sta	$FFD4	sta	$FFC6		VIDEO OFFSET = $5800/$200=0010 1100	sta	$FFC8	sta	$FFCA+1	sta	$FFCC+1	sta	$FFCE	sta	$FFD0+1	sta	$FFD2	ldx	#PAGE1	stx	TL	SET TL = FIRST BYTE OF UNUSED SCREEN	rtsDISP4		sta	$FFC6		VIDEO OFFSET=$4000/$200=0010 0000	sta	$FFC8	sta	$FFCA	sta	$FFCC	sta	$FFCE	sta	$FFD0+1	sta	$FFD2	ldx	#PAGE2	stx	TL	FIRST BYTE OF UNSEEN VIDEO SCREEN	rts** ROUTINES TO MOVE POINTS*** PAN LEFT*LASTPT	set	POINTS+$9*$19PANL	ldx	#POINTSPANL2	lda	,X	cmpa	#$80	beq	PANL1	ldd	,X	GET X COORDINATE AND SUBTRACT 2	subd	#2	std	,X	cmpa	#-$80	ble	PANL4	POINT OUT OF BOUNDSPANL1	leax	9,X	cmpx	#LASTPT	bls	PANL2	rtsPANL4	lda	,X	SINCE ONE POINT OUT OF BOUNDS, RESTORE ALL POINTS TO ORIGINAL VALUES	cmpa	#$80	beq	PANL5	lda	1,X	adda	#2	sta	1,X	lda	,X	adca	#0	sta	,XPANL5	leax	-9,X	cmpx	#POINTS	bhs	PANL4	rts** PAN RIGHT*PANR	ldx	#POINTSPANR2	lda	,X	cmpa	#$80	beq	PANR1	IF POINT UNDEFINED	ldd	,X	ADD 2 TO X COORDINATE	addd	#2	std	,X	cmpa	#$10	bge	PANR4	POINT OUT OF BOUNDSPANR1	leax	9,X	cmpx	#LASTPT	bls	PANR2	rtsPANR4	lda	,X	SINCE ONE POINT OUT OF BOUNDS, RESTORE ALL POINTS TO  ORIGINAL VALUES	cmpa	#$80	beq	PANR5	lda	1,X	suba	#2	sta	1,X	lda	,X	sbca	#0	sta	,XPANR5	leax	-9,X	cmpx	#POINTS	bhs	PANR4	rts** PAN DOWN*PAND	ldx	#POINTSPAND2	lda	,X	cmpa	#$80	beq	PAND1	IF POINT UNDEFINED	ldd	3,X	SUBTRACT 2 FROM Y COORDINATE	subd	#2	std	3,X	cmpa	#-$10	ble	PAND4	IF POINT OUT OF BOUNDSPAND1	leax	9,X	cmpx	#LASTPT	bls	PAND2	rtsPAND4	lda	,X		SINCE ONE POINT OUT OF BOUNDS, RESTORE ALL POINTS  TO ORIGINAL VALUES	cmpa	#$80	beq	PAND5	lda	4,X	adda	#2	sta	4,X	lda	3,X	adca	#0	sta	3,XPAND5	leax	-9,X	cmpx	#POINTS	bhs	PAND4	rts** PAN UP* PANU	ldx	#POINTSPANU2	lda	,X	cmpa	#$80	beq	PANU1	IF POINT UNDEFINED	ldd	3,X	ADD 2 TO Y COORDINATE	addd	#2	std	3,X	cmpa	#$10	bge	PANU4	POINT OUT OF BOUNDSPANU1	leax	9,X	cmpx	#LASTPT	bls	PANU2	rtsPANU4	lda	,X	SINCE ONE POINT OUT OF BOUNDS, RESTORE ALL POINTS  TO ORIGINAL VALUES	cmpa	#$80	beq	PANU5	lda	4,X	suba	#2	sta	4,X	lda	3,X	sbca	#0	sta	3,XPANU5	leax	-9,X	cmpx	#POINTS	bhs	PANU4	rts** ROTATE POSITIVELY ABOUT X AXIS*ROTX	ldx	#POINTSROTX1	lda	,X	cmpa	#$80	CHECK FOR UNDEFINED POINT	beq	ROTX2	pshs	X	leax	3,X	ADDRESS OF Y-COORDINATE OF CURRENT POINT	leay	3,X	ADDRESS OF Z-COORDINATE OF CURRENT POINT	jsr	ROTATE	puls	X	lda	3,X	cmpa	#$10	bge	ROTX3	cmpa	#-$10	ble	ROTX3	POINT TOO BIG	lda	6,X	cmpa	#$10	bge	ROTX3	cmpa	#-$10	ble	ROTX3ROTX2	leax	9,X	GET NEXT POINT	cmpx	#LASTPT	ble	ROTX1	rtsROTX3	pshs	X	UNDO ROTATIONS AS  ONE POINT TOO LARGE	lda	,X	cmpa	#$80	beq	RX	leay	3,X	leax	6,X	jsr	ROTATERX	puls	X	leax	-9,X	cmpx	#POINTS	bhs	ROTX3	rts** ROTATE NEGATIVELY ABOUT X AXIS*ROTMX	ldx	#POINTSROTMX1	lda	,X	cmpa	#$80	CHECK FOR UNDEFINED POINT	beq	ROTMX2	pshs	X	leay	3,X	ADDRESS OF Y-COORDINATE OF CURRENT POINT	leax	6,X	ADDRESS OF Z-COORDINATE OF CURRENT POINT	jsr	ROTATE	puls	X	lda	3,X	cmpa	#$10	bge	ROTMX3	cmpa	#-$10	ble	ROTMX3	POINT TOO BIG	lda	6,X	cmpa	#$10	bge	ROTMX3	cmpa	#-$10	ble	ROTMX3ROTMX2	leax	9,X	GET NEXT POINT	cmpx	#LASTPT	ble	ROTMX1	rtsROTMX3	pshs	X	UNDO ROTATIONS AS  ONE POINT TOO LARGE	lda	,X	cmpa	#$80	beq	RMX	leax	3,X	leay	3,X	jsr	ROTATERMX	puls	X	leax	-9,X	cmpx	#POINTS	bhs	ROTMX3	rts** ROTATE POSITIVELY ABOUT Y AXIS*ROTY	ldx	#POINTSROTY1	lda	,X	cmpa	#$80	CHECK FOR UNDEFINED POINT	beq	ROTY2	pshs	X	leay	,X	ADDRESS OF X-COORDINATE OF CURRENT POINT	leax	6,X	ADDRESS OF Z-COORDINATE OF CURRENT POINT	jsr	ROTATE	puls	X	lda	,X	cmpa	#$10	bge	ROTY3	cmpa	#-$10	ble	ROTY3	POINT TOO BIG	lda	6,X	cmpa	#$10	bge	ROTY3	cmpa	#-$10	ble	ROTY3ROTY2	leax	9,X	GET NEXT POINT	cmpx	#LASTPT	ble	ROTY1	rtsROTY3	pshs	X	UNDO ROTATIONS AS  ONE POINT TOO LARGE	lda	,X	cmpa	#$80	beq	RY	leay	6,X	jsr	ROTATERY	puls	X	leax	-9,X	cmpx	#POINTS	bhs	ROTY3	rts** ROTATE NEGATIVELY ABOUT Y AXIS*ROTMY	ldx	#POINTSROTMY1	lda	,X	cmpa	#$80	CHECK FOR UNDEFINED POINT	beq	ROTMY2	pshs	X	leay	6,X	ADDRESS OF Z-COORDINATE OF CURRENT POINT--X CONTAINS X-COORD	jsr	ROTATE	puls	X	lda	,X	cmpa	#$10	bge	ROTMY3	cmpa	#-$10	ble	ROTMY3	POINT TOO BIG	lda	6,X	cmpa	#$10	bge	ROTMY3	cmpa	#-$10	ble	ROTMY3ROTMY2	leax	9,X	GET NEXT POINT	cmpx	#LASTPT	ble	ROTMY1	rtsROTMY3	pshs	X	UNDO ROTATIONS AS  ONE POINT TOO LARGE	lda	,X	cmpa	#$80	beq	RMY	leay	,X	leax	6,X	jsr	ROTATERMY	puls	X	leax	-9,X	cmpx	#POINTS	bhs	ROTMY3	rts** ROTATE POSITIVELY ABOUT Z AXIS*ROTZ	ldx	#POINTSROTZ1	lda	,X	cmpa	#$80	CHECK FOR UNDEFINED POINT	beq	ROTZ2	pshs	X	leay	3,X	ADDRESS OF Y-COORDINATE OF CURRENT POINT--X HAS X-COORDINATE	jsr	ROTATE	puls	X	lda	,X	cmpa	#$10	bge	ROTZ3	cmpa	#-$10	ble	ROTZ3	POINT TOO BIG	lda	3,X	cmpa	#$10	bge	ROTZ3	cmpa	#-$10	ble	ROTZ3ROTZ2	leax	9,X	GET NEXT POINT	cmpx	#LASTPT	ble	ROTZ1	rtsROTZ3	pshs	X	UNDO ROTATIONS AS  ONE POINT TOO LARGE	lda	,X	cmpa	#$80	beq	RZ	leay	,X	leax	3,X	jsr	ROTATERZ	puls	X	leax	-9,X	cmpx	#POINTS	bhs	ROTZ3	rts* * ROTATE NEGATIVELY ABOUT Z AXIS*ROTMZ	ldx	#POINTSROTMZ1	lda	,X	cmpa	#$80	CHECK FOR UNDEFINED POINT	beq	ROTMZ2	pshs	X	leay	,X	ADDRESS OF X-COORDINATE OF CURRENT POINT	leax	3,X	ADDRESS OF Y-COORDINATE OF CURRENT POINT	jsr	ROTATE	puls	X	lda	,X	cmpa	#$10	bge	ROTMZ3	cmpa	#-$10	ble	ROTMZ3	POINT TOO BIG	lda	3,X	cmpa	#$10	bge	ROTMZ3	cmpa	#-$10	ble	ROTMZ3ROTMZ2	leax	9,X	GET NEXT POINT	cmpx	#LASTPT	ble	ROTMZ1	rtsROTMZ3	pshs	X	UNDO ROTATIONS AS  ONE POINT TOO LARGE	lda	,X	cmpa	#$80	beq	RMZ	leay	3,X	jsr	ROTATE	puls	XRMZ	leax	-9,X	cmpx	#POINTS	bhs	ROTMZ3	rts** ROTATE AROUND SOME AXIS AS FOLLOWS:  X = COORD POINTED AT BY X-REG, Y=COORD POINTED AT BY Y-REG* X,Y=(127/128)X-(1/8)Y,(1/8)X+127/128)Y*ROTATE	leau	-6,S	ldd	,X	std	,U	std	3,U	lda	2,X	sta	2,U	sta	5,U	asr	3,U	ror	4,U	ror	5,U	asr	3,U	ror	4,U	ror	5,U	asr	3,U	ror	4,U	ror	5,U	asr	3,U	ror	4,U	ror	5,U	asr	3,U	ror	4,U	ror	5,U	asr	3,U	ror	4,U	ror	5,U	asr	3,U	ror	4,U	ror	5,U	lda	2,U	suba	5,U	sta	2,U	lda	1,U	sbca	4,U	sta	1,U	lda	,U	sbca	3,U	sta	,U	ldd	,Y	std	3,U	lda	2,Y	sta	5,U	asr	3,U	ror	4,U	ror	5,U	asr	3,U	ror	4,U	ror	5,U	asr	3,U	ror	4,U	ror	5,U	lda	2,U	suba	5,U	sta	2,U	lda	1,U	sbca	4,U	sta	1,U	lda	,U	sbca	3,U	sta	,U	ldd	,U	std	,X	lda	2,U	sta	2,X	ldd	,Y	std	3,U	lda	2,Y	sta	5,U	asr	,U	ror	1,U	ror	2,U	asr	,U	ror	1,U	ror	2,U	asr	,U	ror	1,U	ror	2,U	ldd	1,U	addd	4,U	std	1,U	lda	,U	adca	3,U	sta	,U	asr	3,U	ror	4,U	ror	5,U	asr	3,U	ror	4,U	ror	5,U	asr	3,U	ror	4,U	ror	5,U	asr	3,U	ror	4,U	ror	5,U	asr	3,U	ror	4,U	ror	5,U	asr	3,U	ror	4,U	ror	5,U	asr	3,U	ror	4,U	ror	5,U	ldd	1,U	addd	4,U	std	1,U	lda	,U	adca	3,U	sta	,U	ldd	,U	std	,Y	lda	2,U	sta	2,Y	rts** MAKE THE FIGURE 1/32 BIGGER*BIGGER	ldx	#POINTSBIG1	lda	,X	CHECK IF POINT IS DEFINED	cmpa	#$80	beq	BIG2	jsr	GETBIG	INCREASE ALL THREE COORDINATES	leax	3,X	jsr	GETBIG	leax	3,X	jsr	GETBIG	leax	-6,X	leay	,X	CHEC IF ANY OF 3 COORDS TOO BIG	jsr	TOOBIG	bge	BIG3	leay	3,Y	jsr	TOOBIG	bge	BIG3	leay	3,Y	jsr	TOOBIG	bge	BIG3BIG2	leax	9,X	GET NEXT POINT	cmpx	#LASTPT	ble	BIG1	rtsBIG3	lda	,X	RESTORE POINTS IF ONE MADE OUT OF BOUNDS	cmpa	#$80	bne	BIG8	leax	-9,X	bra	BIG9BIG8	jsr	GETSML	leax	3,X	jsr	GETSML	leax	3,X	jsr	GETSML	leax	-$F,XBIG9	cmpx	#POINTS	bhs	BIG3	rtsGETBIG	leau	-3,S	MAKE ONE COORDINATE 1/32 BIGGER	ldd	,X	std	,U	lda	2,X	sta	2,U	asr	,U	ror	1,U	ror	2,U	asr	,U	ror	1,U	ror	2,U	asr	,U	ror	1,U	ror	2,U	asr	,U	ror	1,U	ror	2,U	asr	,U	ror	1,U	ror	2,U	ldd	1,X	addd	1,U	std	1,X	lda	,X	adca	,U	sta	,X	rtsTOOBIG	lda	,Y	CHECK IF A COORDINATE TOO BIG--IF FIRST BYTE >= $80 OR <= -$80	cmpa	#$10	bge	TB1	nega	cmpa	#$10TB1	rts		BGE WILL GO IF NUMBER LOADED INTO A WAS >=$10 OR <=-$10** MAKE THE FIGURE 1/32 SMALLER*SMALLR	ldx	#POINTSSML1	lda	,X	CHECK IF POINT IS DEFINED	cmpa	#$80	beq	SML2	jsr	GETSML	leax	3,X	jsr	GETSML	leax	3,X	jsr	GETSML	leax	3,X	bra	SMLR1SML2	leax	9,X	GET NEXT POINTSMLR1	cmpx	#LASTPT	ble	SML1* CHECK FOR LINE SEGMENT LENGTH < 1 -- IF ONE FOUND, RESTORE POINTS TO ORIGINAL VALUES	ldu	#LINESSMLR6	clra	ldb	,U+	cmpb	#$FF	beq	SMLR5	LAST LINE SEGMENT TESTED	addd	#POINTS	tfr	D,X	ADDRESS OF FIRST POINT	clra	ldb	,U+	addd	#POINTS	tfr	D,Y	ADDRESS OF SECOND POINT	ldd	,X	cmpd	,Y	TEST FIRST COORD	bne	SMLR6	INTEGER PARTS NOT EQUAL	ldd	3,X	cmpd	3,Y	bne	SMLR6	INTEGER PARTS OF SECOND COORD NOT EQUAL	ldd	6,X	cmpd	6,Y	bne	SMLR6	INTEGER PARTS OF THIRD COORD NOT EQUAL* ALL COMPONENTS OF LINE SEGMENT HAVE EQUAL INTEGER PARTS, SO UNDO SMALLER AND RTS FROM BIGGER	lbra	BIGGERSMLR5	rts		ALL LINE SEGMENTS CHECKED AND LONG ENOUGHGETSML	leau	-3,S	ldd	,X	std	,U	lda	2,X	sta	2,U	asr	,U	ror	1,U	ror	2,U	asr	,U	ror	1,U	ror	2,U	asr	,U	ror	1,U	ror	2,U	asr	,U	ror	1,U	ror	2,U	asr	,U	ror	1,U	ror	2,U	ldd	1,X	subd	1,U	std	1,X	lda	,X	sbca	,U	sta	,X	rts** SUM KEY BUFFERS TO B-REGISTER.  USED TO DETERMINE IF KEY STILL DEPRESSED*KEYVAL	ldb	$152	addb	$153	addb	$154	addb	$155	addb	$156	addb	$157	addb	$158	addb	$159	rts** DRAW A LINE.  X1,X2 TO Y1,Y2 - COORDINATES ARE SIGNED 16 BIT INTEGERS, VISIBLE SCREEN IS -128 TO 127, -95 TO 95 ON USUAL* X,Y GRAPH*BITS	fcb	$80	FOR SETTING POINTS ON GRAPHICS SCREEN	fcb	$40	fcb	$20	fcb	$10	fcb	$8	fcb	$4	fcb	$2LASTBT	fcb	$1TOP	equ	$5F	LIMITS OF VIRTUAL SCREENBOTTOM	equ	-$60LEFT	equ	-$80RIGHT	equ	$7FX1	rmb	1	2-BYTE COORDINATES FOR TWO POINTSX1P	rmb	1Y1	rmb	1Y1P	rmb	1X2	rmb	1X2P	rmb	1Y2	rmb	1Y2P	rmb	1SLOPE	rmb	1** BEGIN LINE DRAWING ALGORITHM** MAKE SURE X1<X2 OR REVERSE COORDINATES*LINE	ldd	X2	cmpd	X1	bge	LN1	ldx	X1	std	X1	stx	X2	ldx	Y1	ldy	Y2	stx	Y2	sty	Y1** CHECK FOR SIGN OF SLOPE*LN1	ldd	Y2	cmpd	Y1	lblt	SELINE** BEGIN DRAWING LINE WITH POSITIVE SLOPE** CHECK FOR NO VISIBLE LINE*	ldd	X1	cmpd	#RIGHT	lbge	LNDONE	ldd	Y1	cmpd	#TOP	lbge	LNDONE	ldd	X2	cmpd	#LEFT	lble	LNDONE	ldd	Y2	cmpd	#BOTTOM	lble	LNDONE** CHECK IF MUST CLIP LEFT END OF LINE*	ldd	X1	cmpd	#LEFT	blt	LN2	ldd	Y1	cmpd	#BOTTOM	bge	LN3** CLIP LEFT END OF LINE*LN2	ldx	X2	ldy	Y2	pshs	X,YLN4	ldd	X1	X=(X1+X2)/2	addd	X2	asra	rorb	tfr	D,X	ldd	Y1	Y=(Y1+Y2)/2	addd	Y2	asra	rorb	tfr	D,Y	cmpx	#LEFT	bgt	LN5	cmpy	#TOP	lbge	LNDON1	NO VISIBLE LINELN5	cmpx	#RIGHT	blt	LN6	cmpy	#BOTTOM	lble	LNDON1	NO VISIBLE LINELN6	cmpx	#LEFT	blt	LN7	cmpy	#BOTTOM	bge	LN8LN7	stx	X1	REPLACE LEFT POINT BY MIDPOINT AND REPEAT	sty	Y1	bra	LN4LN8	cmpx	#LEFT	ble	LN9	cmpy	#BOTTOM	ble	LN9	stx	X2	REPLACE RIGHT POINT BY MIDPOINT	sty	Y2	bra	LN4LN9	stx	X1	X1,Y1 NOW ON LEFT OR BOTTOM BOUNDARY	sty	Y1	puls	X,Y	RECOVER ORIGINAL RIGHT POINT	stx	X2	sty	Y2* CHECK IF MUST CLIP RIGHT END OF LINE*LN3	ldd	X2	cmpd	#RIGHT	bgt	LN10	ldd	Y2	cmpd	#TOP	ble	LN18** CLIP RIGHT END OF LINE*LN10	ldx	X1	ldy	Y1	pshs	X,YLN11	ldd	X1	X=(X1+X2)/2	addd	X2	asra	rorb	tfr	D,X	ldd	Y1	Y=(Y1+Y2)/2	addd	Y2	asra	rorb	tfr	D,Y	cmpx	#RIGHT	bgt	LN12	cmpy	#TOP	ble	LN13LN12	stx	X2	MOVE RIGHT POINT TO MIDPOINT AND REPEAT	sty	Y2	bra	LN11LN13	cmpx	#RIGHT	bge	LN14	cmpy	#TOP	bge	LN14	stx	X1	MOVE LEFT POINT TO MIDPOINT AND REPEAT	sty	Y1	bra	LN11LN14	stx	X2	MOVE X2,Y2 TO TOP OR RIGHT BOUNDARY, RECOVER X1,Y1	sty	Y2	puls	X,Y	stx	X1	sty	Y1** DECIDE IF SLOPE > 1*LN18	lda	X2P	X1P, ETC HOLD CORRECT ONE-BYTE SIGNED VALUES FOR THE COORDINATES, WHICH ARE NOW ON THE VIRTUAL SCREEN	suba	X1P	pshs	A	ldb	Y2P	subb	Y1P	cmpb	,S+	blo	ENELN** DRAW A LINE WITH POSITIVE SLOPE*	pshs	B	SAVE NUMBER OF POINTS ON LINE - 1	jsr	GETSLP	SLOPE = DX/DY, AN 8-BIT FRACTION	jsr	FRSTBT	SET X,U TO POINT TO BYTE AND BIT ON GRAPHICS SCREEN CORRESP. TO X1,Y1	puls	B	clra	tfr	D,Y	leay	1,Y	Y=#POINTS ON LINE	clrbLN15	lda	,X	SET THE POINTS ON THE GRAPHICS SCREEN FOR THE LINE	ora	,U	GET THE BYTE AND OR IN THE BIT	sta	,X	leay	-1,Y	REDUCE POINT COUNT	lbeq	LNDONE	leax	-$20,X	INCREASE Y-COORDINATE BY 1	addb	SLOPE	INCREASE X-COORDINATE BY SLOPE (A FRACTION)	bcc	LN15	B=X MOD 1	leau	1,U	INCREASE X-COORDINATE BY 1	cmpu	#LASTBT	TRY TO MOVE RIGHT ONE BIT	bls	LN15	ldu	#BITS	ELSE USE NEXT BYTE AND LEFT BIT	leax	1,X	bra	LN15** DRAW LINE WITH POSITIVE SLOPE <1*ENELN	pshs	A	SAVE # OF POINTS ON LINE - 1	exg	A,B	jsr	GETSLP	SLOPE = DY/DX	jsr	FRSTBT	X,U ARE BYTE AND BIT CORRESP. TO X1,Y1	puls	B	clra	tfr	D,Y	leay	1,Y	Y=#POINTS ON LINE	clrbLN16	lda	,X	DRAW THE LINE	ora	,U	GET THE BYTE, OR IN  THE BIT	sta	,X	leay	-1,Y	REDUCE THE POINT COUNT	lbeq	LNDONE	leau	1,U	MOVE ONE BIT TO RIGHT	cmpu	#LASTBT	IF POSSIBLE	bls	LN17	leax	1,X	ELSE MOVE TO NEXT BYTE AND FIRST BIT	ldu	#BITSLN17	addb	SLOPE	bcc	LN16	NO OVERFLO TO NEXT INTEGER WHEN ADDING SLOPE TO Y	leax	-$20,X	ELSE ADD 1 TO Y-COORDINATE	BRA	LN16** BEGIN DRAWING LINE WITH NEGATIVE SLOPE** CHECK FOR NO VISIBLE LINE*SELINE	ldd	X1	cmpd	#RIGHT	lbge	LNDONE	ldd	Y1	cmpd	#BOTTOM	lble	LNDONE	ldd	X2	cmpd	#LEFT	lble	LNDONE	ldd	Y2	cmpd	#TOP	lbge	LNDONE** CHECK IF MUST CLIP LEFT END OF LINE*	ldd	X1	cmpd	#LEFT	blt	LN2A	ldd	Y1	cmpd	#TOP	ble	LN3A** CLIP LEFT END OF LINE FT END OF LI*LN2A	ldx	X2	ldy	Y2	pshs	X,YLN4A	ldd	X1	X=(X1+X2)/2	addd	X2	asra	rorb	tfr	D,X	ldd	Y1	Y=(Y1+Y2)/2	addd	Y2	asra	rorb	tfr	D,Y	cmpx	#LEFT	bgt	LN5A	cmpy	#BOTTOM	lble	LNDON1	NO VISIBLE LINELN5A	cmpx	#RIGHT	blt	LN6A	cmpy	#TOP	lbge	LNDON1	NO VISIBLE LINELN6A	cmpx	#LEFT	blt	LN7A	cmpy	#TOP	ble	LN8ALN7A	stx	X1	REPLACE LEFT POINT BY MIDPOINT AND REPEAT	sty	Y1	bra	LN4ALN8A	cmpx	#LEFT	ble	LN9A	cmpy	#TOP	bge	LN9A	stx	X2	REPLACE RIGHT POINT BY MIDPOINT	sty	Y2	bra	LN4ALN9A	stx	X1	X1,Y1 NOW ON LEFT OR BOTTOM BOUNDARY	sty	Y1	puls	X,Y	RECOVER ORIGINAL RIGHT POINT	stx	X2	sty	Y2* CHECK IF MUST CLIP RIGHT END OF LINE*LN3A	ldd	X2	cmpd	#RIGHT	bgt	LN10A	ldd	Y2	cmpd	#BOTTOM	bge	LN18A** CLIP RIGHT END OF LINE*LN10A	ldx	X1	ldy	Y1	pshs	X,YLN11A	ldd	X1	X=(X1+X2)/2	addd	X2	asra	rorb	tfr	D,X	ldd	Y1	Y=(Y1+Y2)/2	addd	Y2	asra	rorb	tfr	D,Y	cmpx	#RIGHT	bgt	LN12A	cmpy	#BOTTOM	bge	LN13ALN12A	stx	X2	MOVE RIGHT POINT TO MIDPOINT AND REPEAT	sty	Y2	bra	LN11ALN13A	cmpx	#RIGHT	bge	LN14A	cmpy	#BOTTOM	ble	LN14A	stx	X1	MOVE LEFT POINT TO MIDPOINT AND REPEAT	sty	Y1	bra	LN11ALN14A	stx	X2	MOVE X2,Y2 TO TOP OR RIGHT BOUNDARY, RECOVER X1,Y1	sty	Y2		puls	X,Y	stx	X1	sty	Y1** DECIDE IF SLOPE > 1*LN18A	lda	X2P	X1P, ETC HOLD CORRECT ONE-BYTE SIGNED VALUES FOR THE COORDINATES, WHICH ARE NOW ON THE VIRTUAL SCREEN	suba	X1P	pshs	A	ldb	Y1P	subb	Y2P	cmpb	,S+	blo	ESELN** DRAW A LINE WITH NEGATIVE SLOPE <= -1*	pshs	B	SAVE NUMBER OF POINTS ON LINE - 1	jsr	GETSLP	SLOPE = -DX/DY, AN 8-BIT FRACTION	jsr	FRSTBT	SET X,U TO POINT TO BYTE AND BIT ON GRAPHICS SCREEN CORRESP. TO X1,Y1	puls	B	clra	tfr	D,Y	leay	1,Y	Y=#POINTS ON LINE	clrbLN15A	lda	,X	SET THE POINTS ON THE GRAPHICS SCREEN FOR THE LINE	ora	,U	GET THE BYTE AND OR IN THE BIT	sta	,X	leay	-1,Y	REDUCE POINT COUNT	lbeq	LNDONE	leax	$20,X	DECREASE Y-COORDINATE BY 1	addb	SLOPE	INCREASE X-COORDINATE BY SLOPE (A FRACTION)	bcc	LN15A	B=X MOD 1	leau	1,U	INCREASE X-COORDINATE BY 1	cmpu	#LASTBT	TRY TO MOVE RIGHT ONE BIT	bls	LN15A	ldu	#BITS	ELSE USE NEXT BYTE AND LEFT BIT	leax	1,X	bra	LN15A** DRAW LINE WITH NEGATIVE SLOPE > -1*ESELN	pshs	A	SAVE # POINTS ON LINE - 1	exg	A,B	jsr	GETSLP	SLOPE = -DY/DX	jsr	FRSTBT	X,U ARE BYTE AND BIT CORRESP. TO X1,Y1	puls	B	clra	tfr	D,Y	leay	1,Y	Y=#POINTS ON LINE	clrbLN16A	lda	,X	DRAW THE LINE	ora	,U	GET THE BYTE, OR IN  THE BIT	sta	,X	leay	-1,Y	REDUCE THE POINT COUNT	lbeq	LNDONE	leau	1,U	MOVE ONE BIT TO THE RIGHT	cmpu	#LASTBT	IF POSSIBLE	bls	LN17A	leax	1,X	ELSE MOVE TO NEXT BYTE AND FIRST BIT	ldu	#BITSLN17A	addb	SLOPE	bcc	LN16A	NO OVERFLO TO NEXT INTEGER WHEN ADDING SLOPE TO Y	leax	$20,X	ELSE SUBTRACT 1 FROM Y-COORDINATE	bra	LN16ALNDON1	puls	X,YLNDONE	rts** ASSUME A<B CONTAIN UNSIGNED INTEGERS, PUT A/B INTO SLOPE*GETSLP	pshs	B	clrb	ldx	#8GET5	aslb	asla	bcs	GET1	cmpa	,S	blo	GET4GET1	suba	,S	incbGET4	leax	-1,X	bne	GET5	leas	1,S	stb	SLOPE	rts** FIND BYTE X AND BIT (U) ON GRAPHICS SCREEN CORRESPONDING TO X1,Y1* X=$600+Y1*32+X1DIV8 AND U=#BITS+X1MOD8* WE USE $600+Y1*(256/8)+X1DIV8 FOR X, AND AS WE DIVIDE X1 BY THREE SUCCESSIVE 2'S, WE PICK UP THE BITS FOR MODIFYING U.*FRSTBT	ldx	TL	lda	#95	suba	Y1P	ldb	X1P	addb	#$80	ldu	#BITS	andcc	#$FE	rora	rorb	bcc	FRST1	leau	1,UFRST1	asra	rorb	bcc	FRST2	leau	2,UFRST2	asra	rorb	bcc	FRST3	leau	4,UFRST3	leax	D,X	rts	endฺ& d PROGRAM DISPLAY &; n COPYRIGHT DAVID MEREDITH 1983 &ป x BASIC PROGRAM PERMITS INPUT OF A 3-D PICTURE AS POINTS AND LINE SEGMENTS. MACHINE LANGUAGE COMPONENT DISPLAYS THE PICTURE &๋  AND ALLOWS PANNING, SCALING, AND ROTATING &  300,&H3FFF 'H :@73,"D I S P L A Y":@135,"BY DAVID MEREDITH":@201,"COPYRIGHT 1983" 'u @416,"READING MACHINE LANGUAGE PART..." ' ำM"DISPLAY2" '๎ POณ&H7000:LIณPOซ9ญ26:MAณLIซ121: ADDRESSES OF POINTS BUFFER, LINES BUFFER, AND MAIN DISPLAY ROUTINE '๛ ฅ CH(25) ( ชฆ 1000: NEW PICTURE (Z ฏCS$ณ"HELPNEWDISPLAY":LD$ณ"LOAD":SV$ณ"SAVE":AAณ("A"):QU$ณ(34) ( ด:"ENTER help ANYTIME FOR GUIDANCE" (ฏ พป A$: GET NEW POINT, LINE, OR COMMAND ) ศIณ(A$," "): Iดฒ0 ง A$ณ(A$,Iฌ1)ซ(A$,(A$)ฌI):ฅ 200: ELIMINATE BLANKS )z า (A$) ฒ2 ง Iณ(CS$,A$): Iณ0 ง 215 :  Iณ1 ง ฆ 1600:ฅ 190 :  Iณ5 ง ฆ 1000:ฅ 190 :  Iณ8 ง ฆ 1800:ฅ 190 )ม ื (A$,LD$)ณ1 ง ฆ 1200:ฅ 190 :  (A$,SV$)ณ1 ง ฆ 1400:ฅ 190 )๖  (A$,"=")ณ2 ง ฆ 2000:ฅ 190: DEFINE A POINT *1 ๆ (A$,"??")ณ1 ง ฆ 2200:ฅ 190: PRINT LINE SEGMENTS *d ๐ (A$,"?")ณ1 ง ฆ 2400:ฅ 190: PRINT POINTS * ๚	AT THIS POINT A$ EITHER DEFINES LINES OR IS INCORRECT *่Lณ(A$): Lด2 ง ฆ 2600:ฅ 190: IF LEN(A$) <2 THEN LINE INCORRECT +g Lด2 ง 190 : A1ณ((A$,1))ฌAA:A2ณ((A$,2,1))ฌAA: A1ด0 ฑ A1ฒ25 ฑ A2ด0 ฑ A2ฒ25 ง ฆ 2600:ฅ 190 : LณLฌ2:A$ณ(A$,L) + A1ณA2 ง:"ENDPOINTS MUST BE DISTINCT"::ฅ190 + (A$,"#")ณ1 ง LณLฌ1:A$ณ(A$,L):ฅ 400: DELETE A POINT +๔IณLI:A1ณ9ญA1:A2ณ9ญA2 ,ฦ"Pณ(I):Qณ(Iซ1): P ดฒ 255 ง  (PณA1 ฐ QณA2) ฑ (PณA2 ฐ QณA1)ง :"LINE ";(AAซA1ฎ9);(AAซA2ฎ9);" ALREADY DEFINED"::ฅ 190 : IณIซ2:ฅ 290: FIND NEXT OPEN SPACE IN LINES BUFFERCHECKING FOR DUPLICATION ,๛, IณMAฌ1 ง :"NO ROOM FOR ANOTHER LINE"::ฅ190 -A6 (POซA1)ณ128 ง :"POINT ";(A1ฎ9ซAA);" NOT DEFINED"::ฅ 270 -@ (POซA2)ณ128 ง :"POINT ";(A2ฎ9ซAA);" NOT DEFINED"::ฅ 270 -๖J I,A1: Iซ1,A2: Iซ2,255: Lฒ0 ง 270 : 190: PUT LINE SEGMENT IN LINE BUFFER AND GET NEXT SEGMENT IF ANY .	DELETE A LINE SEGMENT A1,A2 .1IณLI:A1ณ9ญA1:A2ณ9ญA2 .ค (I)ณ255 ง :"LINE SEGMENT ";(A1ฎ9ซAA);(A2ฎ9ซAA);" NOT DEFINED"::ฅ 270 .ฮฎPณ(I):Qณ(Iซ1): (PดฒA1 ฑ QดฒA2) ฐ (PดฒA2 ฑ QดฒA1)ง IณIซ2:ฅ 420 /2ธPณ(Iซ2): I,P: Pณ255 ง 270 : IณIซ1:ฅ 440: DELETE THE POINT BY MOVING DATA DOWN THE BUFFER /M่ MAKE A BLANK PICTURE /๒ IณPO ฅ POซ9ญ25 ฉ 9: I,128:: MARK ALL POINTS AS UNDEFINED /ฐ LI,255: CLEAR LINE BUFFER /ถ /ีฐ LOAD A PICTURE FROM DISK 03บIณ(A$,QU$):Iดฒ0งJณ(Iซ1,A$,QU$):Jดฒ0งNA$ณ(A$,I,JฌIซ1):NA$ณ(A$,(A$)ฌI):NA$ณ"" 0Pฤ(NA$)ฒ8งNA$ณ(NA$,8) 0aฮำM NA$ซ".3D" 0ุฅ 1800: DISPLAY PICTURE AFTER LOADING 0ฐx SAVE CURRENT PICTURE ON DISK 1Iณ(A$,QU$):Iดฒ0งJณ(Iซ1,A$,QU$):Jดฒ0งNA$ณ(A$,I,JฌIซ1):NA$ณ(A$,(A$)ฌI):NA$ณ"" 1+(NA$)ฒ8งNA$ณ(NA$,8) 1IุM NA$ซ".3D",PO,MAฌ1,PO: 1\@ HELP ROUTINE 1J:"DISPLAY PICTURE:  display" 1ดO"...PRESS x,y,z,s,b AND @ TO EXIT": &H400ซ55,0 1ฯT"ERASE PICTURE:  new" 1^"SAVE PIX ON DISK:  save";QU$;"NAME";QU$ 2-h"READ PIX FROM DISK:  load";QU$;"NAME";QU$ 2Nr"ENTER POINT P:  P = X,Y,Z" 2p|"ENTER LINE SEGMENT AB:  AB" 2"DELETE LINE SEGMENT CD:  CD#" 2ถ"PRINT POINTS A TO H:  ?A-H" 2ึ"PRINT LINE SEGMENTS:  ??" 2ค: 2๘ DISPLAY THE PICTURE 3+ FIRST DECLARE ALL UNUSED POINTS AS UNDEFINED 3AIณ0ฅ25:CH(I)ณ0: 3J&IณLI 30Pณ(I):Pดฒ255งCH(Pฎ9)ณ1:IณIซ1:ฅ1840: MARK ALL POINT NAMES USED 3ึ:Iณ0ฅ25:CH(I)ณ0งPOซ9ญI,128:: MARK UNUSED POINTS AS UNDEFINED 3๔D 282,0:ข MA:282,255:: 4ะ INPUT A POINT 47ฺAณ((A$,1))ฌAA: Aด0 ฑ Aฒ25 ง ฆ 2600: 4EไADณPOซ9ญA 4\๎A$ณ(A$,(A$)ฌ2) 4t๘ A$ณ"" ง ฆ 2600: 4้VAณ(A$): (VA) ฒ 80 ง :"COORDINATES MUST BE BETWEEN -80 AND 80":: : Bณ(A$)ฌ((VA)): VA ด0 ง BณBฌ1 5< Bด3 ง ฆ 2600:ฅ 190 : A$ณ(A$,B): VAฒณ0 ง V1ณ0:V2ณVA : V1ณ255:V2ณ256ซVA 5c AD,V1: ADซ1,V2: ADซ2,0:ADณADซ3 5{ A$ณ"" ง ฆ 2600: 5๐ VAณ(A$): (VA) ฒ 80 ง :"COORDINATES MUST BE BETWEEN -80 AND 80":: : Bณ(A$)ฌ((VA)): VA ด0 ง BณBฌ1 6B% Bด1 ง ฆ 2600:ฅ190 : A$ณ(A$,B): VAฒณ0 ง V1ณ0:V2ณVA : V1ณ255:V2ณ256ซVA 6i* AD,V1: ADซ1,V2: ADซ2,0:ADณADซ3 6ด\VAณ(A$):(VA)ฒ80 ง :"COORDINATES MUST BE BETWEEN -80 AND 80":: 6aVAฒณ0งV1ณ0:V2ณVA :V1ณ255:V2ณ256ซVA 6f AD,V1:ADซ1,V2:ADซ2,0: 7 PRINT LINES 7ขIณLI 71ฌPณ(I): Pณ255 ง : 7dถ(Pฎ9ซAA);((Iซ1)ฎ9ซAA);" ";:IณIซ2:ฅ2220 7w	` PRINT POINTS 7ล	jA1ณ0:A2ณ25:Iณ(A$,"-"):Iณ3งA1ณ((A$,2,1))ฌAA:A1ด0ฑA1ฒ25งA1ณ0:ฅ2030 8	tIด(A$)ฐIดณ3งA2ณ((A$,Iซ1,1))ฌAA:A2ด0ฑA2ฒ25งA2ณ25 8*	~IณA1 ฅ A2:ADณPOซ9ญI:(AD)ณ128ง: 8H	(IซAA);" = ";:Jณ0ฅ6ฉ3 8	VAณ(ADซJ)ญ256ซ(ADซJซ1)ซ(ADซJซ2)ฎ256:VAฒ32767งVAณVAฌ65536 8ซ	V$ณ(VA):V$;:Jดฒ6ง","; 8ท	ก::: 8ู
(:"UNRECOGNIZED COMMAND"::      @  	qc4P@ทืฦOื๓&=3ไฮ 4@ฝq5@2ฤทึ๓&= 59ทภทรทลถ"๐ท"'ฝrq฿ฆทถ C4ฆ@คเก'0m&ๅ ื4ญ5 ํ~s~Hsโ}t+}Htr{tน{Hu ๗sc๏s-฿rมฟr๗๛v*๗vทr 2d9๓&r* ;!  ฬ  1 ฟrDฬ  ํํํํ  &๓ฮp๊ๆภม'+Oรp ฎค๔1#ฎค๖ๆภOรp ฎค๘1#ฎค๚4@ฝwB5@ ฯถ*๛@ 'ทิทฦทศทหทอทฮทัทา@ 9ทฦทศทสทฬทฮทัทาX 9p ฆ'์ ํ/0	pแ#่9ฆ'ฆงฆ ง0p $็9p ฆ'์ร ํ,0	pแ#่9ฆ'ฆงฆ ง0p $็9p ฆ'์ ํ๐/0	pแ#่9ฆ'ฆงฆ ง0p $็9p ฆ'์ร ํ,0	pแ#่9ฆ'ฆงฆ ง0p $็9p ฆ'401ฝuG5ฆ,๐/ฆ,๐/0	pแ/ิ94ฆ'10ฝuG50p $่9p ฆ'410ฝuG5ฆ,๐/ฆ,๐/0	pแ/ิ94ฆ'01ฝuG50p $่9p ฆ'410ฝuG5ฆ,๐/ฆ,๐/0	pแ/ิ94ฆ'1ฝuG50p $๊9p ฆ'41ฝuG5ฆ,๐/ฆ,๐/0	pแ/ึ94ฆ'10ฝuG50p $่9p ฆ'41ฝuG5ฆ,๐/ฆ,๐/0	pแ/ึ94ฆ'10ฝuG50p $่9p ฆ'410ฝuG5ฆ,๐/ฆ,๐/0	pแ/ิ94ฆ'1ฝuG50p $๊93z์ํฤํCฆงBงEgCfDfEgCfDfEgCfDfEgCfDfEgCfDfEgCfDfEgCfDfEฆBEงBฆAขDงAฆฤขCงฤ์คํCฆ"งEgCfDfEgCfDfEgCfDfEฆBEงBฆAขDงAฆฤขCงฤ์ฤํฆBง์คํCฆ"งEgฤfAfBgฤfAfBgฤfAfB์AใDํAฆฤฉCงฤgCfDfEgCfDfEgCfDfEgCfDfEgCfDfEgCfDfEgCfDfE์AใDํAฆฤฉCงฤ์ฤํคฆBง"9p ฆ'C0?0;01j,1#d,1#^,0	pแ/ี9ฆ&0 ฝw0ฝw0ฝw0p $โ93}์ํฤฆงBgฤfAfBgฤfAfBgฤfAfBgฤfAfBgฤfAfB์ใAํฆฉฤง9ฆค,@9p ฆ'C0?0;0 0	pแ/ๅฮp๊Oๆภม'%รp Oๆภรp ์ฃค&ๅ์ฃ#&์ฃ&&ื&93}์ํฤฆงBgฤfAfBgฤfAfBgฤfAfBgฤfAfBgฤfAfB์ฃAํฆขฤง9@ ๘๔,๔๔๘๖๚๚๖๚๖-d๔ ,ภ๖ _,ถ๘/ฌ๚/ข๔-๖,a๘๚40๔ำ๘GV๖ำ๚GV. _,l -/_-,๔๖ ฤ//๘๚ ฒ๔๖50๘๚๘ .๚ _/G๔๖40๔ำ๘GV๖ำ๚GV . _/๘๚  , _,๔๖ ฬ๘๚50๔๖๙๕4ึ๛ะ๗แเ%24ฝz-ฝzG5O1!_ฆชฤง1?'ฐ0เ$ํ3AwA#ๅฮw:0 4ฝz-ฝzG5O1!_ฆชฤง1?'|3AwA#0ฮw:$ใ0เ ๔ ,\๖/R๘/H๚ _,>๔-๖ _/a๘๚40๔ำ๘GV๖ำ๚GV./ - _, ๛- _/๔๖ ฤ/ _,๘๚ ฒ๔๖50๘๚๘ .๚,G๔๖40๔ำ๘GV๖ำ๚GV .,๘๚  ,/๔๖ ฬ๘๚50๔๖๙๕4ึ๗ะ๛แเ%24ฝz-ฝzG5O1!_ฆชฤง1?' L0 $ํ3AwA#ๅฮw:0 4ฝz-ฝzG5O1!_ฆชฤง1?' 3AwA#0ฮw:$ใ0  5094_ XH%กไ%ไ\0&๑2aื9_๗ึ๕หฮw:FV$3AGV$3BGV$3D09    ** PROGRAM <<DISPLAY>>* PAN, SCALE, AND ROTATE CONTENTS OF *POINTS* THEN DISPLAY THE CONTENTS OF *LINES**PAGE1	equ	$4000	; graphics page 1PAGE2	equ	$5800	; graphics page 2	org	$f3	; 13 bytes freeIs6309	rmb	1X1	rmb	1	2-BYTE COORDINATES FOR TWO POINTSX1P	rmb	1Y1	rmb	1Y1P	rmb	1X2	rmb	1X2P	rmb	1Y2	rmb	1Y2P	rmb	1SLOPE	rmb	1TL	fdb	PAGE1	CONTAINS THE ADDRESS OF THE FIRST BYTE OF THE PRESENTLY UNSEEN GRAPHICS SCREEN--PRE-INITIALIZEDDIRTY	rmb	1		org	$7000** BASIC DATA STRUCTURES--THE POINTS AND LINES TO BE DRAWN. POINTS MAINTAINS THE COORDINATES OF THE POINTS*POINTS	rmb	9*26	STORE THREE COORDS OF THREE BYTES EACH LABELED A..Z FOR THE USER* UNUSED POINTS HAVE $80 IN THE FIRST BYTE OF EACH COORDINATELINES	rmb	121	UP TO 30 PAIRS OF POINTS, LAST PAIR FOLLOWED BY -1, POINT L REPRESENTED BY 9*(ASC(L)-ASC(A))** INTRODUCTORY HOUSEKEEPING TO DISABLE BASIC INTERRUPTS AND CREATE NEW STACK THEN RESTORE ENVIRONMENT FOR RETURN TO BASIC*	opt	6309	pshs	cc	orcc	#$50		DISABLE REGULAR INTERRUPT	clr	$ff40		TURN OFF DRIVE MOTOR	sta	$ffd7		HIGH SPEED	ldb	#$ff 	clrd			executes as a $10 (ignored) $4f (clra) on a 6809a@	stb	<Is6309	bne	b@	ldmd	#1		enable 6309 native modeb@	leau	,S	lds	#$8000		USE HIGH MEMORY FOR HARDWARE STACK	pshs	U	jsr	MAIN	puls	U	leas	,U		RESTORE HARDWARE STACK	sta	$ffd6	tst	<Is6309	bne	c@	ldmd	#0c@	puls	cc,pc	rts	opt	6809 ** MAIN DISPLAY LOOP--LOOKS FOR A KEY COMMANDING ROTATION, PANNING, OR SCALING AND ORDERS SAME. INCLUDES AUTO REPEAT*MAIN	sta	$FFC0		SET VDG = 110	sta	$FFC3	sta	$FFC5	lda	$FF22		SET HI BITS CONTROL REGISTER = $F0	anda	#7	ora	#$F0	sta	$FF22	lda	#1	sta	<DIRTYa@	tst	<DIRTY	beq	b@	clr	<DIRTY	jsr	DISPLA		DISPLAY THE PICTUREb@	ldx	#CommandTablec@	lda	,x	sta	$ff02	lda	$ff00	coma	pshs	a	lda	1,x	ora	#%01000000	PRESERVE SHIFT	anda	,s+	cmpa	1,x	beq	e@d@	leax	4,x	tst	,x	bne	c@	bra	a@e@	pshs	x	jsr	[2,x]	puls	x	inc	<DIRTY	bra	d@CommandTable:	fdb	%0111111000001000,ROTX		X	fdb	%0111111001001000,ROTMX		SHIFT X	fdb	%0111110100001000,ROTY		Y	fdb	%0111110101001000,ROTMY		SHIFT Y	fdb	%0111101100001000,ROTZ		Z	fdb	%0111101101001000,ROTMZ		SHIFT Z	fdb	%1111011100001000,PANU		UP ARROW	fdb	%1110111100001000,PAND		DOWN ARROW	fdb	%1101111100001000,PANL		LEFT ARROW	fdb	%1011111100001000,PANR		RIGHT ARROW	fdb	%1111101100000001,BIGGER	B	fdb	%1111011100000100,SMALLR	S	fdb	%1111111000000001,EXIT		@	fcb	0				END OF TABLEEXIT	leas	4,s	rts** CREATE A PICTURE USING CURRENT POINTS AND LINES ON THE UNSEEN GRAPHICS SCREEN THEN DISPLAY THAT SCREEN*** PLOT THE CURRENT LINES ON THE UNSEEN GRAPHICS SCREEN THEN DISPLAY THE SCREEN*DISPLA  tst	<Is6309	bne	a@	opt	6309	ldx	<TL	ldy	#zero@	ldw	#6144	tfm	y,x+	bra	z@zero@   fcb     0	opt	6809a@	ldd	#0		BLANK SCREEN	ldx	<TL	leay	6144,x	sty	c@+1	ldd	#0b@	std	,x++	std	,x++	std	,x++	std	,x++c@	cmpx	#0	bne	b@z@** PLOT EACH LINE*	ldu	#LINESDISP3	ldb	,U+	cmpb	#$FF	beq	DISP2		LAST POINT?	clraP1300	addd	#POINTS	tfr	D,Y		ADDRESS OF FIRST POINT	ldx	,Y	stx	<X1	leay	3,Y	ldx	,Y	stx	<Y1	ldb	,U+	clra	addd	#POINTS	tfr	D,Y		ADDRESS OF SECOND POINT	ldx	,Y	stx	<X2	leay	3,Y	ldx	,Y	stx	<Y2	pshs	U	jsr	LINE	puls	U	bra	DISP3** SWITCH SCREENS TO SHOW NEW PICTURE*DISP2	lda	$ff03	bpl	DISP2		VSYNC	ldx	<TL	cmpx	#PAGE1	beq	DISP4	sta	$FFD4	sta	$FFC6		VIDEO OFFSET = $5800/$200=0010 1100	sta	$FFC8	sta	$FFCA+1	sta	$FFCC+1	sta	$FFCE	sta	$FFD0+1	sta	$FFD2	ldx	#PAGE1	stx	<TL		SET TL = FIRST BYTE OF UNUSED SCREEN	rtsDISP4	sta	$FFC6		VIDEO OFFSET=$4000/$200=0010 0000	sta	$FFC8	sta	$FFCA	sta	$FFCC	sta	$FFCE	sta	$FFD0+1	sta	$FFD2	ldx	#PAGE2	stx	<TL		FIRST BYTE OF UNSEEN VIDEO SCREEN	rts** ROUTINES TO MOVE POINTS*** PAN LEFT*LASTPT	set	POINTS+$9*$19PANL	ldx	#POINTSPANL2	lda	,X	cmpa	#$80	beq	PANL1	ldd	,X		GET X COORDINATE AND SUBTRACT 2	subd	#2	std	,X	cmpa	#-$80	ble	PANL4		POINT OUT OF BOUNDSPANL1	leax	9,X	cmpx	#LASTPT	bls	PANL2	rtsPANL4	lda	,X		SINCE ONE POINT OUT OF BOUNDS, RESTORE ALL POINTS TO ORIGINAL VALUES	cmpa	#$80	beq	PANL5	lda	1,X	adda	#2	sta	1,X	lda	,X	adca	#0	sta	,XPANL5	leax	-9,X	cmpx	#POINTS	bhs	PANL4	rts** PAN RIGHT*PANR	ldx	#POINTSPANR2	lda	,X	cmpa	#$80	beq	PANR1		IF POINT UNDEFINED	ldd	,X		ADD 2 TO X COORDINATE	addd	#2	std	,X	cmpa	#$10	bge	PANR4		POINT OUT OF BOUNDSPANR1	leax	9,X	cmpx	#LASTPT	bls	PANR2	rtsPANR4	lda	,X		SINCE ONE POINT OUT OF BOUNDS, RESTORE ALL POINTS TO  ORIGINAL VALUES	cmpa	#$80	beq	PANR5	lda	1,X	suba	#2	sta	1,X	lda	,X	sbca	#0	sta	,XPANR5	leax	-9,X	cmpx	#POINTS	bhs	PANR4	rts** PAN DOWN*PAND	ldx	#POINTSPAND2	lda	,X	cmpa	#$80	beq	PAND1		IF POINT UNDEFINED	ldd	3,X		SUBTRACT 2 FROM Y COORDINATE	subd	#2	std	3,X	cmpa	#-$10	ble	PAND4		IF POINT OUT OF BOUNDSPAND1	leax	9,X	cmpx	#LASTPT	bls	PAND2	rtsPAND4	lda	,X		SINCE ONE POINT OUT OF BOUNDS, RESTORE ALL POINTS  TO ORIGINAL VALUES	cmpa	#$80	beq	PAND5	lda	4,X	adda	#2	sta	4,X	lda	3,X	adca	#0	sta	3,XPAND5	leax	-9,X	cmpx	#POINTS	bhs	PAND4	rts** PAN UP* PANU	ldx	#POINTSPANU2	lda	,X	cmpa	#$80	beq	PANU1	IF POINT UNDEFINED	ldd	3,X	ADD 2 TO Y COORDINATE	addd	#2	std	3,X	cmpa	#$10	bge	PANU4	POINT OUT OF BOUNDSPANU1	leax	9,X	cmpx	#LASTPT	bls	PANU2	rtsPANU4	lda	,X	SINCE ONE POINT OUT OF BOUNDS, RESTORE ALL POINTS  TO ORIGINAL VALUES	cmpa	#$80	beq	PANU5	lda	4,X	suba	#2	sta	4,X	lda	3,X	sbca	#0	sta	3,XPANU5	leax	-9,X	cmpx	#POINTS	bhs	PANU4	rts** ROTATE POSITIVELY ABOUT X AXIS*ROTX	ldx	#POINTSROTX1	lda	,X	cmpa	#$80	CHECK FOR UNDEFINED POINT	beq	ROTX2	pshs	X	leax	3,X	ADDRESS OF Y-COORDINATE OF CURRENT POINT	leay	3,X	ADDRESS OF Z-COORDINATE OF CURRENT POINT	jsr	ROTATE	puls	X	lda	3,X	cmpa	#$10	bge	ROTX3	cmpa	#-$10	ble	ROTX3	POINT TOO BIG	lda	6,X	cmpa	#$10	bge	ROTX3	cmpa	#-$10	ble	ROTX3ROTX2	leax	9,X	GET NEXT POINT	cmpx	#LASTPT	ble	ROTX1	rtsROTX3	pshs	X	UNDO ROTATIONS AS  ONE POINT TOO LARGE	lda	,X	cmpa	#$80	beq	RX	leay	3,X	leax	6,X	jsr	ROTATERX	puls	X	leax	-9,X	cmpx	#POINTS	bhs	ROTX3	rts** ROTATE NEGATIVELY ABOUT X AXIS*ROTMX	ldx	#POINTSROTMX1	lda	,X	cmpa	#$80	CHECK FOR UNDEFINED POINT	beq	ROTMX2	pshs	X	leay	3,X	ADDRESS OF Y-COORDINATE OF CURRENT POINT	leax	6,X	ADDRESS OF Z-COORDINATE OF CURRENT POINT	jsr	ROTATE	puls	X	lda	3,X	cmpa	#$10	bge	ROTMX3	cmpa	#-$10	ble	ROTMX3	POINT TOO BIG	lda	6,X	cmpa	#$10	bge	ROTMX3	cmpa	#-$10	ble	ROTMX3ROTMX2	leax	9,X	GET NEXT POINT	cmpx	#LASTPT	ble	ROTMX1	rtsROTMX3	pshs	X	UNDO ROTATIONS AS  ONE POINT TOO LARGE	lda	,X	cmpa	#$80	beq	RMX	leax	3,X	leay	3,X	jsr	ROTATERMX	puls	X	leax	-9,X	cmpx	#POINTS	bhs	ROTMX3	rts** ROTATE POSITIVELY ABOUT Y AXIS*ROTY	ldx	#POINTSROTY1	lda	,X	cmpa	#$80	CHECK FOR UNDEFINED POINT	beq	ROTY2	pshs	X	leay	,X	ADDRESS OF X-COORDINATE OF CURRENT POINT	leax	6,X	ADDRESS OF Z-COORDINATE OF CURRENT POINT	jsr	ROTATE	puls	X	lda	,X	cmpa	#$10	bge	ROTY3	cmpa	#-$10	ble	ROTY3	POINT TOO BIG	lda	6,X	cmpa	#$10	bge	ROTY3	cmpa	#-$10	ble	ROTY3ROTY2	leax	9,X	GET NEXT POINT	cmpx	#LASTPT	ble	ROTY1	rtsROTY3	pshs	X	UNDO ROTATIONS AS  ONE POINT TOO LARGE	lda	,X	cmpa	#$80	beq	RY	leay	6,X	jsr	ROTATERY	puls	X	leax	-9,X	cmpx	#POINTS	bhs	ROTY3	rts** ROTATE NEGATIVELY ABOUT Y AXIS*ROTMY	ldx	#POINTSROTMY1	lda	,X	cmpa	#$80	CHECK FOR UNDEFINED POINT	beq	ROTMY2	pshs	X	leay	6,X	ADDRESS OF Z-COORDINATE OF CURRENT POINT--X CONTAINS X-COORD	jsr	ROTATE	puls	X	lda	,X	cmpa	#$10	bge	ROTMY3	cmpa	#-$10	ble	ROTMY3	POINT TOO BIG	lda	6,X	cmpa	#$10	bge	ROTMY3	cmpa	#-$10	ble	ROTMY3ROTMY2	leax	9,X	GET NEXT POINT	cmpx	#LASTPT	ble	ROTMY1	rtsROTMY3	pshs	X	UNDO ROTATIONS AS  ONE POINT TOO LARGE	lda	,X	cmpa	#$80	beq	RMY	leay	,X	leax	6,X	jsr	ROTATERMY	puls	X	leax	-9,X	cmpx	#POINTS	bhs	ROTMY3	rts** ROTATE POSITIVELY ABOUT Z AXIS*ROTZ	ldx	#POINTSROTZ1	lda	,X	cmpa	#$80	CHECK FOR UNDEFINED POINT	beq	ROTZ2	pshs	X	leay	3,X	ADDRESS OF Y-COORDINATE OF CURRENT POINT--X HAS X-COORDINATE	jsr	ROTATE	puls	X	lda	,X	cmpa	#$10	bge	ROTZ3	cmpa	#-$10	ble	ROTZ3	POINT TOO BIG	lda	3,X	cmpa	#$10	bge	ROTZ3	cmpa	#-$10	ble	ROTZ3ROTZ2	leax	9,X	GET NEXT POINT	cmpx	#LASTPT	ble	ROTZ1	rtsROTZ3	pshs	X	UNDO ROTATIONS AS  ONE POINT TOO LARGE	lda	,X	cmpa	#$80	beq	RZ	leay	,X	leax	3,X	jsr	ROTATERZ	puls	X	leax	-9,X	cmpx	#POINTS	bhs	ROTZ3	rts* * ROTATE NEGATIVELY ABOUT Z AXIS*ROTMZ	ldx	#POINTSROTMZ1	lda	,X	cmpa	#$80	CHECK FOR UNDEFINED POINT	beq	ROTMZ2	pshs	X	leay	,X	ADDRESS OF X-COORDINATE OF CURRENT POINT	leax	3,X	ADDRESS OF Y-COORDINATE OF CURRENT POINT	jsr	ROTATE	puls	X	lda	,X	cmpa	#$10	bge	ROTMZ3	cmpa	#-$10	ble	ROTMZ3	POINT TOO BIG	lda	3,X	cmpa	#$10	bge	ROTMZ3	cmpa	#-$10	ble	ROTMZ3ROTMZ2	leax	9,X	GET NEXT POINT	cmpx	#LASTPT	ble	ROTMZ1	rtsROTMZ3	pshs	X	UNDO ROTATIONS AS  ONE POINT TOO LARGE	lda	,X	cmpa	#$80	beq	RMZ	leay	3,X	jsr	ROTATE	puls	XRMZ	leax	-9,X	cmpx	#POINTS	bhs	ROTMZ3	rts** ROTATE AROUND SOME AXIS AS FOLLOWS:  X = COORD POINTED AT BY X-REG, Y=COORD POINTED AT BY Y-REG* X,Y=(127/128)X-(1/8)Y,(1/8)X+127/128)Y*ROTATE	leau	-6,S	ldd	,X	std	,U	std	3,U	lda	2,X	sta	2,U	sta	5,U	asr	3,U	ror	4,U	ror	5,U	asr	3,U	ror	4,U	ror	5,U	asr	3,U	ror	4,U	ror	5,U	asr	3,U	ror	4,U	ror	5,U	asr	3,U	ror	4,U	ror	5,U	asr	3,U	ror	4,U	ror	5,U	asr	3,U	ror	4,U	ror	5,U	lda	2,U	suba	5,U	sta	2,U	lda	1,U	sbca	4,U	sta	1,U	lda	,U	sbca	3,U	sta	,U	ldd	,Y	std	3,U	lda	2,Y	sta	5,U	asr	3,U	ror	4,U	ror	5,U	asr	3,U	ror	4,U	ror	5,U	asr	3,U	ror	4,U	ror	5,U	lda	2,U	suba	5,U	sta	2,U	lda	1,U	sbca	4,U	sta	1,U	lda	,U	sbca	3,U	sta	,U	ldd	,U	std	,X	lda	2,U	sta	2,X	ldd	,Y	std	3,U	lda	2,Y	sta	5,U	asr	,U	ror	1,U	ror	2,U	asr	,U	ror	1,U	ror	2,U	asr	,U	ror	1,U	ror	2,U	ldd	1,U	addd	4,U	std	1,U	lda	,U	adca	3,U	sta	,U	asr	3,U	ror	4,U	ror	5,U	asr	3,U	ror	4,U	ror	5,U	asr	3,U	ror	4,U	ror	5,U	asr	3,U	ror	4,U	ror	5,U	asr	3,U	ror	4,U	ror	5,U	asr	3,U	ror	4,U	ror	5,U	asr	3,U	ror	4,U	ror	5,U	ldd	1,U	addd	4,U	std	1,U	lda	,U	adca	3,U	sta	,U	ldd	,U	std	,Y	lda	2,U	sta	2,Y	rts** MAKE THE FIGURE 1/32 BIGGER*BIGGER	ldx	#POINTSBIG1	lda	,X	CHECK IF POINT IS DEFINED	cmpa	#$80	beq	BIG2	bsr	GETBIG	INCREASE ALL THREE COORDINATES	leax	3,X	bsr	GETBIG	leax	3,X	bsr	GETBIG	leax	-6,X	leay	,X	CHEC IF ANY OF 3 COORDS TOO BIG	bsr	TOOBIG	bge	BIG3	leay	3,Y	bsr	TOOBIG	bge	BIG3	leay	3,Y	bsr	TOOBIG	bge	BIG3BIG2	leax	9,X	GET NEXT POINT	cmpx	#LASTPT	ble	BIG1	rtsBIG3	lda	,X	RESTORE POINTS IF ONE MADE OUT OF BOUNDS	cmpa	#$80	bne	BIG8	leax	-9,X	bra	BIG9BIG8	jsr	GETSML	leax	3,X	jsr	GETSML	leax	3,X	jsr	GETSML	leax	-$F,XBIG9	cmpx	#POINTS	bhs	BIG3	rtsGETBIG	leau	-3,S	MAKE ONE COORDINATE 1/32 BIGGER	ldd	,X	std	,U	lda	2,X	sta	2,U	asr	,U	ror	1,U	ror	2,U	asr	,U	ror	1,U	ror	2,U	asr	,U	ror	1,U	ror	2,U	asr	,U	ror	1,U	ror	2,U	asr	,U	ror	1,U	ror	2,U	ldd	1,X	addd	1,U	std	1,X	lda	,X	adca	,U	sta	,X	rtsTOOBIG	lda	,Y	CHECK IF A COORDINATE TOO BIG--IF FIRST BYTE >= $80 OR <= -$80	cmpa	#$10	bge	TB1	nega	cmpa	#$10TB1	rts		BGE WILL GO IF NUMBER LOADED INTO A WAS >=$10 OR <=-$10** MAKE THE FIGURE 1/32 SMALLER*SMALLR	ldx	#POINTSSML1	lda	,X	CHECK IF POINT IS DEFINED	cmpa	#$80	beq	SML2	bsr	GETSML	leax	3,X	bsr	GETSML	leax	3,X	bsr	GETSML	leax	3,X	bra	SMLR1SML2	leax	9,X	GET NEXT POINTSMLR1	cmpx	#LASTPT	ble	SML1* CHECK FOR LINE SEGMENT LENGTH < 1 -- IF ONE FOUND, RESTORE POINTS TO ORIGINAL VALUES	ldu	#LINESSMLR6	clra	ldb	,U+	cmpb	#$FF	beq	SMLR5	LAST LINE SEGMENT TESTED	addd	#POINTS	tfr	D,X	ADDRESS OF FIRST POINT	clra	ldb	,U+	addd	#POINTS	tfr	D,Y	ADDRESS OF SECOND POINT	ldd	,X	cmpd	,Y	TEST FIRST COORD	bne	SMLR6	INTEGER PARTS NOT EQUAL	ldd	3,X	cmpd	3,Y	bne	SMLR6	INTEGER PARTS OF SECOND COORD NOT EQUAL	ldd	6,X	cmpd	6,Y	bne	SMLR6	INTEGER PARTS OF THIRD COORD NOT EQUAL* ALL COMPONENTS OF LINE SEGMENT HAVE EQUAL INTEGER PARTS, SO UNDO SMALLER AND RTS FROM BIGGER	lbra	BIGGERSMLR5	rts		ALL LINE SEGMENTS CHECKED AND LONG ENOUGHGETSML	leau	-3,S	ldd	,X	std	,U	lda	2,X	sta	2,U	asr	,U	ror	1,U	ror	2,U	asr	,U	ror	1,U	ror	2,U	asr	,U	ror	1,U	ror	2,U	asr	,U	ror	1,U	ror	2,U	asr	,U	ror	1,U	ror	2,U	ldd	1,X	subd	1,U	std	1,X	lda	,X	sbca	,U	sta	,X	rts** DRAW A LINE.  X1,X2 TO Y1,Y2 - COORDINATES ARE SIGNED 16 BIT INTEGERS, VISIBLE SCREEN IS -128 TO 127, -95 TO 95 ON USUAL* X,Y GRAPH*BITS	fcb	$80	FOR SETTING POINTS ON GRAPHICS SCREEN	fcb	$40	fcb	$20	fcb	$10	fcb	$8	fcb	$4	fcb	$2LASTBT	fcb	$1TOP	equ	$5F	LIMITS OF VIRTUAL SCREENBOTTOM	equ	-$60LEFT	equ	-$80RIGHT	equ	$7F** BEGIN LINE DRAWING ALGORITHM** MAKE SURE X1<X2 OR REVERSE COORDINATES*LINE	ldd	<X2	cmpd	<X1	bge	LN1	ldx	<X1	std	<X1	stx	<X2	ldx	<Y1	ldy	<Y2	stx	<Y2	sty	<Y1** CHECK FOR SIGN OF SLOPE*LN1	ldd	<Y2	cmpd	<Y1	lblt	SELINE** BEGIN DRAWING LINE WITH POSITIVE SLOPE** CHECK FOR NO VISIBLE LINE*	ldd	<X1	cmpd	#RIGHT	lbge	LNDONE	ldd	<Y1	cmpd	#TOP	lbge	LNDONE	ldd	<X2	cmpd	#LEFT	lble	LNDONE	ldd	<Y2	cmpd	#BOTTOM	lble	LNDONE** CHECK IF MUST CLIP LEFT END OF LINE*	ldd	<X1	cmpd	#LEFT	blt	LN2	ldd	<Y1	cmpd	#BOTTOM	bge	LN3** CLIP LEFT END OF LINE*LN2	ldx	<X2	ldy	<Y2	pshs	X,YLN4	ldd	<X1	X=(X1+X2)/2	addd	<X2	asra	rorb	tfr	D,X	ldd	<Y1	Y=(Y1+Y2)/2	addd	<Y2	asra	rorb	tfr	D,Y	cmpx	#LEFT	bgt	LN5	cmpy	#TOP	lbge	LNDON1	NO VISIBLE LINELN5	cmpx	#RIGHT	blt	LN6	cmpy	#BOTTOM	lble	LNDON1	NO VISIBLE LINELN6	cmpx	#LEFT	blt	LN7	cmpy	#BOTTOM	bge	LN8LN7	stx	<X1	REPLACE LEFT POINT BY MIDPOINT AND REPEAT	sty	<Y1	bra	LN4LN8	cmpx	#LEFT	ble	LN9	cmpy	#BOTTOM	ble	LN9	stx	<X2	REPLACE RIGHT POINT BY MIDPOINT	sty	<Y2	bra	LN4LN9	stx	<X1	X1,Y1 NOW ON LEFT OR BOTTOM BOUNDARY	sty	<Y1	puls	X,Y	RECOVER ORIGINAL RIGHT POINT	stx	<X2	sty	<Y2* CHECK IF MUST CLIP RIGHT END OF LINE*LN3	ldd	<X2	cmpd	#RIGHT	bgt	LN10	ldd	<Y2	cmpd	#TOP	ble	LN18** CLIP RIGHT END OF LINE*LN10	ldx	<X1	ldy	<Y1	pshs	X,YLN11	ldd	<X1	X=(X1+X2)/2	addd	<X2	asra	rorb	tfr	D,X	ldd	<Y1	Y=(Y1+Y2)/2	addd	<Y2	asra	rorb	tfr	D,Y	cmpx	#RIGHT	bgt	LN12	cmpy	#TOP	ble	LN13LN12	stx	<X2	MOVE RIGHT POINT TO MIDPOINT AND REPEAT	sty	<Y2	bra	LN11LN13	cmpx	#RIGHT	bge	LN14	cmpy	#TOP	bge	LN14	stx	<X1	MOVE LEFT POINT TO MIDPOINT AND REPEAT	sty	<Y1	bra	LN11LN14	stx	<X2	MOVE X2,Y2 TO TOP OR RIGHT BOUNDARY, RECOVER X1,Y1	sty	<Y2	puls	X,Y	stx	<X1	sty	<Y1** DECIDE IF SLOPE > 1*LN18	lda	<X2P	X1P, ETC HOLD CORRECT ONE-BYTE SIGNED VALUES FOR THE COORDINATES, WHICH ARE NOW ON THE VIRTUAL SCREEN	suba	<X1P	pshs	A	ldb	<Y2P	subb	<Y1P	cmpb	,S+	blo	ENELN** DRAW A LINE WITH POSITIVE SLOPE*	pshs	B	SAVE NUMBER OF POINTS ON LINE - 1	jsr	GETSLP	SLOPE = DX/DY, AN 8-BIT FRACTION	jsr	FRSTBT	SET X,U TO POINT TO BYTE AND BIT ON GRAPHICS SCREEN CORRESP. TO X1,Y1	puls	B	clra	tfr	D,Y	leay	1,Y	Y=#POINTS ON LINE	clrbLN15	lda	,X	SET THE POINTS ON THE GRAPHICS SCREEN FOR THE LINE	ora	,U	GET THE BYTE AND OR IN THE BIT	sta	,X	leay	-1,Y	REDUCE POINT COUNT	lbeq	LNDONE	leax	-$20,X	INCREASE Y-COORDINATE BY 1	addb	<SLOPE	INCREASE X-COORDINATE BY SLOPE (A FRACTION)	bcc	LN15	B=X MOD 1	leau	1,U	INCREASE X-COORDINATE BY 1	cmpu	#LASTBT	TRY TO MOVE RIGHT ONE BIT	bls	LN15	ldu	#BITS	ELSE USE NEXT BYTE AND LEFT BIT	leax	1,X	bra	LN15** DRAW LINE WITH POSITIVE SLOPE <1*ENELN	pshs	A	SAVE # OF POINTS ON LINE - 1	exg	A,B	jsr	GETSLP	SLOPE = DY/DX	jsr	FRSTBT	X,U ARE BYTE AND BIT CORRESP. TO X1,Y1	puls	B	clra	tfr	D,Y	leay	1,Y	Y=#POINTS ON LINE	clrbLN16	lda	,X	DRAW THE LINE	ora	,U	GET THE BYTE, OR IN  THE BIT	sta	,X	leay	-1,Y	REDUCE THE POINT COUNT	lbeq	LNDONE	leau	1,U	MOVE ONE BIT TO RIGHT	cmpu	#LASTBT	IF POSSIBLE	bls	LN17	leax	1,X	ELSE MOVE TO NEXT BYTE AND FIRST BIT	ldu	#BITSLN17	addb	<SLOPE	bcc	LN16	NO OVERFLO TO NEXT INTEGER WHEN ADDING SLOPE TO Y	leax	-$20,X	ELSE ADD 1 TO Y-COORDINATE	BRA	LN16** BEGIN DRAWING LINE WITH NEGATIVE SLOPE** CHECK FOR NO VISIBLE LINE*SELINE	ldd	<X1	cmpd	#RIGHT	lbge	LNDONE	ldd	<Y1	cmpd	#BOTTOM	lble	LNDONE	ldd	<X2	cmpd	#LEFT	lble	LNDONE	ldd	<Y2	cmpd	#TOP	lbge	LNDONE** CHECK IF MUST CLIP LEFT END OF LINE*	ldd	<X1	cmpd	#LEFT	blt	LN2A	ldd	<Y1	cmpd	#TOP	ble	LN3A** CLIP LEFT END OF LINE FT END OF LI*LN2A	ldx	<X2	ldy	<Y2	pshs	X,YLN4A	ldd	X1	X=(X1+X2)/2	addd	<X2	asra	rorb	tfr	D,X	ldd	Y1	Y=(Y1+Y2)/2	addd	<Y2	asra	rorb	tfr	D,Y	cmpx	#LEFT	bgt	LN5A	cmpy	#BOTTOM	lble	LNDON1	NO VISIBLE LINELN5A	cmpx	#RIGHT	blt	LN6A	cmpy	#TOP	lbge	LNDON1	NO VISIBLE LINELN6A	cmpx	#LEFT	blt	LN7A	cmpy	#TOP	ble	LN8ALN7A	stx	<X1	REPLACE LEFT POINT BY MIDPOINT AND REPEAT	sty	<Y1	bra	LN4ALN8A	cmpx	#LEFT	ble	LN9A	cmpy	#TOP	bge	LN9A	stx	<X2	REPLACE RIGHT POINT BY MIDPOINT	sty	<Y2	bra	LN4ALN9A	stx	<X1	X1,Y1 NOW ON LEFT OR BOTTOM BOUNDARY	sty	<Y1	puls	X,Y	RECOVER ORIGINAL RIGHT POINT	stx	<X2	sty	<Y2* CHECK IF MUST CLIP RIGHT END OF LINE*LN3A	ldd	<X2	cmpd	#RIGHT	bgt	LN10A	ldd	<Y2	cmpd	#BOTTOM	bge	LN18A** CLIP RIGHT END OF LINE*LN10A	ldx	<X1	ldy	<Y1	pshs	X,YLN11A	ldd	<X1	X=(X1+X2)/2	addd	<X2	asra	rorb	tfr	D,X	ldd	<Y1	Y=(Y1+Y2)/2	addd	<Y2	asra	rorb	tfr	D,Y	cmpx	#RIGHT	bgt	LN12A	cmpy	#BOTTOM	bge	LN13ALN12A	stx	<X2	MOVE RIGHT POINT TO MIDPOINT AND REPEAT	sty	<Y2	bra	LN11ALN13A	cmpx	#RIGHT	bge	LN14A	cmpy	#BOTTOM	ble	LN14A	stx	<X1	MOVE LEFT POINT TO MIDPOINT AND REPEAT	sty	<Y1	bra	LN11ALN14A	stx	<X2	MOVE X2,Y2 TO TOP OR RIGHT BOUNDARY, RECOVER X1,Y1	sty	<Y2		puls	X,Y	stx	<X1	sty	<Y1** DECIDE IF SLOPE > 1*LN18A	lda	<X2P	X1P, ETC HOLD CORRECT ONE-BYTE SIGNED VALUES FOR THE COORDINATES, WHICH ARE NOW ON THE VIRTUAL SCREEN	suba	<X1P	pshs	A	ldb	<Y1P	subb	<Y2P	cmpb	,S+	blo	ESELN** DRAW A LINE WITH NEGATIVE SLOPE <= -1*	pshs	B	SAVE NUMBER OF POINTS ON LINE - 1	jsr	GETSLP	SLOPE = -DX/DY, AN 8-BIT FRACTION	jsr	FRSTBT	SET X,U TO POINT TO BYTE AND BIT ON GRAPHICS SCREEN CORRESP. TO X1,Y1	puls	B	clra	tfr	D,Y	leay	1,Y	Y=#POINTS ON LINE	clrbLN15A	lda	,X	SET THE POINTS ON THE GRAPHICS SCREEN FOR THE LINE	ora	,U	GET THE BYTE AND OR IN THE BIT	sta	,X	leay	-1,Y	REDUCE POINT COUNT	lbeq	LNDONE	leax	$20,X	DECREASE Y-COORDINATE BY 1	addb	<SLOPE	INCREASE X-COORDINATE BY SLOPE (A FRACTION)	bcc	LN15A	B=X MOD 1	leau	1,U	INCREASE X-COORDINATE BY 1	cmpu	#LASTBT	TRY TO MOVE RIGHT ONE BIT	bls	LN15A	ldu	#BITS	ELSE USE NEXT BYTE AND LEFT BIT	leax	1,X	bra	LN15A** DRAW LINE WITH NEGATIVE SLOPE > -1*ESELN	pshs	A	SAVE # POINTS ON LINE - 1	exg	A,B	jsr	GETSLP	SLOPE = -DY/DX	jsr	FRSTBT	X,U ARE BYTE AND BIT CORRESP. TO X1,Y1	puls	B	clra	tfr	D,Y	leay	1,Y	Y=#POINTS ON LINE	clrbLN16A	lda	,X	DRAW THE LINE	ora	,U	GET THE BYTE, OR IN  THE BIT	sta	,X	leay	-1,Y	REDUCE THE POINT COUNT	lbeq	LNDONE	leau	1,U	MOVE ONE BIT TO THE RIGHT	cmpu	#LASTBT	IF POSSIBLE	bls	LN17A	leax	1,X	ELSE MOVE TO NEXT BYTE AND FIRST BIT	ldu	#BITSLN17A	addb	<SLOPE	bcc	LN16A	NO OVERFLO TO NEXT INTEGER WHEN ADDING SLOPE TO Y	leax	$20,X	ELSE SUBTRACT 1 FROM Y-COORDINATE	bra	LN16ALNDON1	puls	X,YLNDONE	rts** ASSUME A<B CONTAIN UNSIGNED INTEGERS, PUT A/B INTO SLOPE*GETSLP	pshs	B	clrb	ldx	#8GET5	aslb	asla	bcs	GET1	cmpa	,S	blo	GET4GET1	suba	,S	incbGET4	leax	-1,X	bne	GET5	leas	1,S	stb	<SLOPE	rts** FIND BYTE X AND BIT (U) ON GRAPHICS SCREEN CORRESPONDING TO X1,Y1* X=$600+Y1*32+X1DIV8 AND U=#BITS+X1MOD8* WE USE $600+Y1*(256/8)+X1DIV8 FOR X, AND AS WE DIVIDE X1 BY THREE SUCCESSIVE 2'S, WE PICK UP THE BITS FOR MODIFYING U.*FRSTBT	ldx	<TL	lda	#95	suba	<Y1P	ldb	<X1P	addb	#$80	ldu	#BITS	andcc	#$FE	rora	rorb	bcc	FRST1	leau	1,UFRST1	asra	rorb	bcc	FRST2	leau	2,UFRST2	asra	rorb	bcc	FRST3	leau	4,UFRST3	leax	D,X	rts	end& d PROGRAM DISPLAY &; n COPYRIGHT DAVID MEREDITH 1983 &ป x BASIC PROGRAM PERMITS INPUT OF A 3-D PICTURE AS POINTS AND LINE SEGMENTS. MACHINE LANGUAGE COMPONENT DISPLAYS THE PICTURE &๋  AND ALLOWS PANNING, SCALING, AND ROTATING ''  (33021) ดฒ 50 ง "THIS VERSION REQUIRES A COCO 3": '8  300,&H3DFF ' :@71,"D I S P L A Y - 3":@135,"BY DAVID MEREDITH":@201,"COPYRIGHT '83" 'ด @416,"READING MACHINE LANGUAGE PART..." 'ล ำM"DISPLAY3" (- POณ&H7000:LIณPOซ9ญ26:MAณLIซ121: ADDRESSES OF POINTS BUFFER, LINES BUFFER, AND MAIN DISPLAY ROUTINE (: ฅ CH(25) (T ชฆ 1000: NEW PICTURE ( ฏCS$ณ"HELPNEWDISPLAY":LD$ณ"LOAD":SV$ณ"SAVE":AAณ("A"):QU$ณ(34) (ย ด:"ENTER help ANYTIME FOR GUIDANCE" (๎ พป A$: GET NEW POINT, LINE, OR COMMAND )@ ศIณ(A$," "): Iดฒ0 ง A$ณ(A$,Iฌ1)ซ(A$,(A$)ฌI):ฅ 200: ELIMINATE BLANKS )น า (A$) ฒ2 ง Iณ(CS$,A$): Iณ0 ง 215 :  Iณ1 ง ฆ 1600:ฅ 190 :  Iณ5 ง ฆ 1000:ฅ 190 :  Iณ8 ง ฆ 1800:ฅ 190 *  ื (A$,LD$)ณ1 ง ฆ 1200:ฅ 190 :  (A$,SV$)ณ1 ง ฆ 1400:ฅ 190 *5  (A$,"=")ณ2 ง ฆ 2000:ฅ 190: DEFINE A POINT *p ๆ (A$,"??")ณ1 ง ฆ 2200:ฅ 190: PRINT LINE SEGMENTS *ฃ ๐ (A$,"?")ณ1 ง ฆ 2400:ฅ 190: PRINT POINTS *฿ ๚	AT THIS POINT A$ EITHER DEFINES LINES OR IS INCORRECT +'Lณ(A$): Lด2 ง ฆ 2600:ฅ 190: IF LEN(A$) <2 THEN LINE INCORRECT +ฆ Lด2 ง 190 : A1ณ((A$,1))ฌAA:A2ณ((A$,2,1))ฌAA: A1ด0 ฑ A1ฒ25 ฑ A2ด0 ฑ A2ฒ25 ง ฆ 2600:ฅ 190 : LณLฌ2:A$ณ(A$,L) + A1ณA2 ง:"ENDPOINTS MUST BE DISTINCT"::ฅ190 , (A$,"#")ณ1 ง LณLฌ1:A$ณ(A$,L):ฅ 400: DELETE A POINT ,3IณLI:A1ณ9ญA1:A2ณ9ญA2 -"Pณ(I):Qณ(Iซ1): P ดฒ 255 ง  (PณA1 ฐ QณA2) ฑ (PณA2 ฐ QณA1)ง :"LINE ";(AAซA1ฎ9);(AAซA2ฎ9);" ALREADY DEFINED"::ฅ 190 : IณIซ2:ฅ 290: FIND NEXT OPEN SPACE IN LINES BUFFERCHECKING FOR DUPLICATION -:, IณMAฌ1 ง :"NO ROOM FOR ANOTHER LINE"::ฅ190 -6 (POซA1)ณ128 ง :"POINT ";(A1ฎ9ซAA);" NOT DEFINED"::ฅ 270 -ฦ@ (POซA2)ณ128 ง :"POINT ";(A2ฎ9ซAA);" NOT DEFINED"::ฅ 270 .5J I,A1: Iซ1,A2: Iซ2,255: Lฒ0 ง 270 : 190: PUT LINE SEGMENT IN LINE BUFFER AND GET NEXT SEGMENT IF ANY .W	DELETE A LINE SEGMENT A1,A2 .pIณLI:A1ณ9ญA1:A2ณ9ญA2 .ลค (I)ณ255 ง :"LINE SEGMENT ";(A1ฎ9ซAA);(A2ฎ9ซAA);" NOT DEFINED"::ฅ 270 /ฎPณ(I):Qณ(Iซ1): (PดฒA1 ฑ QดฒA2) ฐ (PดฒA2 ฑ QดฒA1)ง IณIซ2:ฅ 420 /qธPณ(Iซ2): I,P: Pณ255 ง 270 : IณIซ1:ฅ 440: DELETE THE POINT BY MOVING DATA DOWN THE BUFFER /่ MAKE A BLANK PICTURE /ฮ๒ IณPO ฅ POซ9ญ25 ฉ 9: I,128:: MARK ALL POINTS AS UNDEFINED /๏ LI,255: CLEAR LINE BUFFER /๕ 0ฐ LOAD A PICTURE FROM DISK 0|บIณ(A$,QU$): Iดฒ0 ง Jณ(Iซ1,A$,QU$): Jดฒ0 ง NA$ณ(A$,I,JฌIซ1) : NA$ณ(A$,(A$)ฌI) : NA$ณ"" 0ฤ (NA$)ฒ8 ง NA$ณ(NA$,8) 0ญฮำM NA$ซ".3D" 0ูุฅ 1800: DISPLAY PICTURE AFTER LOADING 0x SAVE CURRENT PICTURE ON DISK 1dIณ(A$,QU$): Iดฒ0 ง Jณ(Iซ1,A$,QU$): Jดฒ0 ง NA$ณ(A$,I,JฌIซ1) : NA$ณ(A$,(A$)ฌI) : NA$ณ"" 1 (NA$)ฒ8 ง NA$ณ(NA$,8) 1ขุM NA$ซ".3D",PO,MAฌ1,PO: 1ต@ HELP ROUTINE 1ุJ:"DISPLAY PICTURE:  display" 2O"...PRESS x,y,z,s,b AND @ TO EXIT": &H400ซ55,0 2(T"ERASE PICTURE:  new" 2V^"SAVE PIX ON DISK:  save";QU$;"NAME";QU$ 2h"READ PIX FROM DISK:  load";QU$;"NAME";QU$ 2งr"ENTER POINT P:  P = X,Y,Z" 2ษ|"ENTER LINE SEGMENT AB:  AB" 2ํ"DELETE LINE SEGMENT CD:  CD#" 3"PRINT POINTS A TO H:  ?A-H" 3/"PRINT LINE SEGMENTS:  ??" 37ค: 3Q DISPLAY THE PICTURE 3 FIRST DECLARE ALL UNUSED POINTS AS UNDEFINED 3 Iณ0 ฅ 25:CH(I)ณ0: 3ฆ&IณLI 3๑0Pณ(I): Pดฒ255 ง CH(Pฎ9)ณ1:IณIซ1:ฅ 1840: MARK ALL POINT NAMES USED 4=: Iณ0 ฅ 25: CH(I)ณ0 ง  POซ9ญI,128:: MARK UNUSED POINTS AS UNDEFINED 4D 282,0:ข MA: 282,255::: TOGGLE LOWERCASE FLAG AND EXECUTE M/L ROUTINE 4ะ INPUT A POINT 4ฯฺAณ((A$,1))ฌAA: Aด0 ฑ Aฒ25 ง ฆ 2600: 4ไADณPOซ9ญA 4๔๎A$ณ(A$,(A$)ฌ2) 5๘ A$ณ"" ง ฆ 2600: 5VAณ(A$): (VA) ฒ 80 ง :"COORDINATES MUST BE BETWEEN -80 AND 80":: : Bณ(A$)ฌ((VA)): VA ด0 ง BณBฌ1 5ิ Bด3 ง ฆ 2600:ฅ 190 : A$ณ(A$,B): VAฒณ0 ง V1ณ0:V2ณVA : V1ณ255:V2ณ256ซVA 5๛ AD,V1: ADซ1,V2: ADซ2,0:ADณADซ3 6 A$ณ"" ง ฆ 2600: 6 VAณ(A$): (VA) ฒ 80 ง :"COORDINATES MUST BE BETWEEN -80 AND 80":: : Bณ(A$)ฌ((VA)): VA ด0 ง BณBฌ1 6ฺ% Bด1 ง ฆ 2600:ฅ190 : A$ณ(A$,B): VAฒณ0 ง V1ณ0:V2ณVA : V1ณ255:V2ณ256ซVA 7* AD,V1: ADซ1,V2: ADซ2,0:ADณADซ3 7M\VAณ(A$): (VA)ฒ80 ง :"COORDINATES MUST BE BETWEEN -80 AND 80":: 7za VAฒณ0 ง V1ณ0:V2ณVA : V1ณ255:V2ณ256ซVA 7f AD,V1: ADซ1,V2: ADซ2,0: 7ญ PRINT LINES 7ถขIณLI 7ะฌPณ(I): Pณ255 ง : 8ถ (Pฎ9ซAA);((Iซ1)ฎ9ซAA);" ";:IณIซ2:ฅ 2220 8	` PRINT POINTS 8o	jA1ณ0:A2ณ25:Iณ(A$,"-"): Iณ3 ง A1ณ((A$,2,1))ฌAA: A1ด0 ฑ A1ฒ25 ง A1ณ0:ฅ 2030 8ต	t Iด(A$) ฐ Iดณ3 ง A2ณ((A$,Iซ1,1))ฌAA: A2ด0 ฑ A2ฒ25 ง A2ณ25 8โ	~ IณA1 ฅ A2:ADณPOซ9ญI: (AD)ณ128 ง : 9	 (IซAA);" = ";: Jณ0 ฅ 6 ฉ 3 9M	VAณ(ADซJ)ญ256ซ(ADซJซ1)ซ(ADซJซ2)ฎ256: VAฒ32767 ง VAณVAฌ65536 9o	V$ณ(VA): V$;: Jดฒ6 ง","; 9{	ก::: 9
(:"UNRECOGNIZED COMMAND"::     >  	qc4P@ทืฦOื &=3ไฮ 4@Dทท(ทOททฐ?ทฑ5@2ฤทึ &= Oญเ5'ฝrขq๒ฆทถ C4ฆ@คเก'0m&ๅ ื4ญ5 ํ~sฯ~Ht}ta}Htจ{t๏{Hu6๗s๏sc฿r๗ฟs-๛v`๗vํ@r+ra 0&ทถ C@&๓&~rd> '> ฬ็ภ W ฬ๊เ92d9&9 &r{ ;! & ฬ  1 ฟrฬ  ํํํํํํํํ  &๋9ภฮp๊ๆภม'+Oรp ฎค1#ฎคๆภOรp ฎค1#ฎค4@ฝws5@ ฯ&> '> ฬ๊เ W ฬ็ภ9p ฆ'์ ํ/0	pแ#่9ฆ'ฆงฆ ง0p $็9p ฆ'์ร ํ,0	pแ#่9ฆ'ฆงฆ ง0p $็9p ฆ'์ ํ๐/0	pแ#่9ฆ'ฆงฆ ง0p $็9p ฆ'์ร ํ,0	pแ#่9ฆ'ฆงฆ ง0p $็9p ฆ'401ฝu}5ฆ,๐/ฆ,๐/0	pแ/ิ94ฆ'10ฝu}50p $่9p ฆ'410ฝu}5ฆ,๐/ฆ,๐/0	pแ/ิ94ฆ'01ฝu}50p $่9p ฆ'410ฝu}5ฆ,๐/ฆ,๐/0	pแ/ิ94ฆ'1ฝu}50p $๊9p ฆ'41ฝu}5ฆ,๐/ฆ,๐/0	pแ/ึ94ฆ'10ฝu}50p $่9p ฆ'41ฝu}5ฆ,๐/ฆ,๐/0	pแ/ึ94ฆ'10ฝu}50p $่9p ฆ'410ฝu}5ฆ,๐/ฆ,๐/0	pแ/ิ94ฆ'1ฝu}50p $๊93z์ํฤํCฆงBงEgCfDfEgCfDfEgCfDfEgCfDfEgCfDfEgCfDfEgCfDfEฆBEงBฆAขDงAฆฤขCงฤ์คํCฆ"งEgCfDfEgCfDfEgCfDfEฆBEงBฆAขDงAฆฤขCงฤ์ฤํฆBง์คํCฆ"งEgฤfAfBgฤfAfBgฤfAfB์AใDํAฆฤฉCงฤgCfDfEgCfDfEgCfDfEgCfDfEgCfDfEgCfDfEgCfDfE์AใDํAฆฤฉCงฤ์ฤํคฆBง"9p ฆ'C0?0;01j,1#d,1#^,0	pแ/ี9ฆ&0 ฝw;0ฝw;0ฝw;0p $โ93}์ํฤฆงBgฤfAfBgฤfAfBgฤfAfBgฤfAfBgฤfAfB์ใAํฆฉฤง9ฆค,@9p ฆ'C0?0;0 0	pแ/ๅฮp๊Oๆภม'%รp Oๆภรp ์ฃค&ๅ์ฃ#&์ฃ&&ื~v`93}์ํฤฆงBgฤfAfBgฤfAfBgฤfAfBgฤfAfBgฤfAfB์ฃAํฆขฤง995ฐ,-Y ,ี _,อ/ล/ฝ-,]40ำGVำGV. _, -/-, ศ// ถ50 . _/G40ำGVำGV . _/  , _, ฬ504ึะแเ%24ฝzCฝz[5O1!_ฆชฤง1?'ฯ0เ	$ํ3Az#ๅฮzx0 4ฝzCฝz[5O1!_ฆชฤง1?'3Az#0ฮzx	$ๅ0เ เ95ฐ ,๕/ํ/ๅ _,- _/]40ำGVำGV./ฌ - _,ก- _/ ศ/ _, ถ50 .,G40ำGVำGV .,  ,/ ฬ504ึะแเ%24ฝzCฝz[5O1!_ฆชฤง1?'v0 	$ํ3Az#ๅฮzx0 4ฝzCฝz[5O1!_ฆชฤง1?'3Az#0ฮzx	$ๅ0  เ9ื
_ XH%
%
\0&๑ื	9_ฦ =0ึหTTT:ฮzx3ฦ9@   qc